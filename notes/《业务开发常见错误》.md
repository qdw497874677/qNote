《Java业务开发常见错误》



## Spring声明式事务

### 注解生效

@Transactional 生效原则：

1. 除非特殊配置（比如使用 AspectJ 静态织入实现 AOP），否则只有定义在 public 方法上的 @Transactional 才能生效
   1. 原因：CGLIB方式可以对public和protected的方法进行增强（因为都对子类可见）。而JDK动态代理方式就只能对public方法进行增强（因为是基于接口，接口中方法默认都是public）。也正是这个原因，所以Spring只对public开启了事务增强的支持，避免当代理方式不一样时导致了事务增强的不一致性。
2. 目标方法被代理，且通过本类外部（除非把自己再注入一下）调用才能生效。
   1. 原因：A类实例a被注入后，public方法被代理，用invoke调用，但是invoke中用到的this.method调用的其实是target的method方法。换而言之，动态代理永远**只能代理一层方法**，如果方法内还是this引导的方法则无法代理，但是如果是static的方法就不存在这个问题。

![img](《业务开发常见错误》.assets/(null))

图中的self就是把自己又注入了进来。

![img](《业务开发常见错误》.assets/(null)-20231024134111034.(null))



### 生效不一定回滚

通过 AOP 实现事务处理可以理解为，使用 try…catch…来包裹标记了 @Transactional 注解的方法，**当方法出现了异常并且满足一定条件的时候**，在 catch 里面我们可以设置事务回滚，没有异常则直接提交事务。

回滚有两个条件

1. 只有异常传播出了标记了 @Transactional 注解的方法，事务才能回滚。
2. 默认情况下，出现 RuntimeException（非受检异常）或 Error 的时候，Spring 才会回滚事务。



## 代码重复

### 用工厂+模板模式，消除ifelse和重复代码

```Java
@GetMapping("right")

public Cart right(@RequestParam("userId") int userId) {

    String userCategory = Db.getUserCategory(userId);

    AbstractCart cart = (AbstractCart) applicationContext.getBean(userCategory + "UserCart");

    return cart.process(userId, items);

}
```



### 利用注解+反射消除重复代码



通过注解，统一对标记了注解的字段进行统一处理。







### 利用属性拷贝工具消除重复代码



### 

## 异步处理

区别于同步处理，异步处理无需同步等待流程处理完毕，因此适用场景主要包括：

- 服务于主流程的分支流程。比如，在注册流程中，把数据写入数据库的操作是主流程，但注册后给用户发优惠券或欢迎短信的操作是分支流程，时效性不那么强，可以进行异步处理。
- 用户不需要实时看到结果的流程。比如，下单后的配货、送货流程完全可以进行异步处理，每个阶段处理完成后，再给用户发推送或短信让用户知晓即可。



异步处理虽然好用，但在实现的时候却有三个最容易犯的错，分别是异步处理流程的可靠性问题、消息发送模式的区分问题，以及大量死信消息堵塞队列的问题。



### 需要消息补偿闭环

主要处理三种情况：1）客户端发送消息给MQ发生异常 2）MQ发送消息给客户端发生异常 3）MQ服务不可用

因此，对于异步处理流程，必须考虑**补偿或者说建立主备双活流程**。



### 注意消息模式是广播还是工作队列



### 别让死信堵塞了消息队列

解决死信无限重复进入队列最简单的方式是，在程序处理出错的时候，直接抛出 AmqpRejectAndDontRequeueException 异常，避免消息重新进入队列



## 线程池

### 线程池需要手动声明

Java 中的 Executors 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 new ThreadPoolExecutor 来创建线程池。这一条规则的背后，是大量血淋淋的生产事故，最典型的就是 newFixedThreadPool 和 newCachedThreadPool，可能因为资源耗尽导致 OOM 问题。

#### newFixedThreadPool 为什么可能会出现 OOM 的问题？

new 了一个 LinkedBlockingQueue，而默认构造方法的 LinkedBlockingQueue 是一个 Integer.MAX_VALUE 长度的队列，可以认为是无界的。

虽然使用 newFixedThreadPool 可以把工作线程控制在固定的数量上，但任务队列是无界的。如果任务较多并且执行较慢的话，队列可能会快速积压，撑爆内存导致 OOM。

#### newCachedThreadPool 为什么可能会出现 OOM 的问题？

这种线程池的最大线程数是 Integer.MAX_VALUE，可以认为是没有上限的，而其工作队列 SynchronousQueue 是一个没有存储空间的阻塞队列。

在任务执行时间比较长，来的新任务又多的情况下，会无线创建新的线程，最终导致OOM。



#### Executors 提供的两种快捷的线程池

不建议使用 Executors 提供的两种快捷的线程池，原因如下：

- 我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。
- 任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量 CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题。



#### 建议增加一下监控手段

除了建议手动声明线程池以外，还建议用一些监控手段来观察线程池的状态。



### 线程池线程管理策略详解

线程池默认的工作行为：

- 不会初始化 corePoolSize 个线程，有任务来了才创建工作线程；
- 当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中；
- 当工作队列满了后扩容线程池，一直到线程个数达到 maximumPoolSize 为止；
- 如果队列已满且达到了最大线程后还有任务进来，按照拒绝策略处理；
- 当线程数大于核心线程数时，线程等待 keepAliveTime 后还是没有任务需要处理的话，收缩线程到核心线程数。

也可以通过一些手段来改变这些默认工作行为，比如：

- 声明线程池后立即调用 prestartAllCoreThreads 方法，来启动所有核心线程；
- 传入 true 给 allowCoreThreadTimeOut 方法，来让线程池在空闲的时候同样回收核心线程。

#### 有没有办法让线程池更激进一点，优先开启更多的线程，而把队列当成一个后备方案呢？

Java 线程池是先用工作队列来存放来不及处理的任务，满了之后再扩容线程池。当我们的工作队列设置得很大时，最大线程数这个参数显得没有意义，因为队列很难满，或者到满的时候再去扩容线程池已经于事无补了。

实现大致思路：

- 由于线程池在工作队列满了无法入队的情况下会扩容线程池，那么我们是否可以重写队列的 offer 方法，造成这个**队列已满的假象**呢？
- 由于我们 Hack 了队列，在达到了最大线程后势必会触发拒绝策略，那么能否实现一个自定义的**拒绝策略**处理程序，这个时候再**把任务真正插入队列**呢？





### 务必确认线程池本身是不是复用的

确保不是每次创建线程的时候创建线程池。保证线程池做到复用，也不能盲目复用，要看适不适合。



### 需要仔细斟酌线程池的混用策略

要根据任务的“轻重缓急”来指定线程池的核心参数，包括线程数、回收策略和任务队列：

- 对于执行比较慢、数量不大的 IO 任务，或许要考虑更多的线程数，而不需要太大的队列。
- 而对于吞吐量较大的计算型任务，线程数量不宜过多，可以是 CPU 核数或核数 *2（理由是，线程一定调度到某个 CPU 进行执行，如果任务本身是 CPU 绑定的任务，那么过多的线程只会增加线程切换的开销，并不能提升吞吐量），但可能需要较长的队列来做缓冲。

**不能盲目复用不同的任务，要看适不适合。**





## 连接池

连接池一般对外提供获得连接、归还连接的接口给客户端使用，并暴露最小空闲连接数、最大连接数等可配置参数，在内部则实现连接建立、连接心跳保持、连接管理、空闲连接回收、连接可用性检测等功能。连接池的结构示意图，如下所示：

![img](《业务开发常见错误》.assets/1685d9db2602e1de8483de171af6fd7e.png)



### 注意鉴别客户端 SDK 是否基于连接池

TCP 是面向连接的基于字节流的协议：

- 面向连接，意味着连接需要先创建再使用，创建连接的三次握手有一定开销；
- 基于字节流，意味着字节是发送数据的最小单元，TCP 协议本身无法区分哪几个字节是完整的消息体，也无法感知是否有多个客户端在使用同一个 TCP 连接，TCP 只是一个读写数据的管道。

使用使用三方客户端进行网络通信时，我们首先要确定客户端 SDK 是否是基于连接池技术实现的。

如果客户端 SDK 没有使用连接池，而直接是 TCP 连接，那么就需要考虑每次建立 TCP 连接的开销，并且因为 TCP 基于字节流，在**多线程的情况下对同一连接进行复用，可能会产生线程安全问题。**

先看一下涉及 TCP 连接的客户端 SDK，对外提供 **API 的三种方式**。

- 连接池和连接分离的 API：有一个 XXXPool 类负责连接池实现，先从其获得连接 XXXConnection，然后用获得的连接进行服务端请求，完成后使用者需要归还连接。通常，XXXPool 是线程安全的，可以并发获取和归还连接，而 XXXConnection 是非线程安全的。对应到连接池的结构示意图中，XXXPool 就是右边连接池那个框，左边的客户端是我们自己的代码。
- 内部带有连接池的 API：对外提供一个 XXXClient 类，通过这个类可以直接进行服务端请求；这个类内部维护了连接池，SDK 使用者无需考虑连接的获取和归还问题。一般而言，XXXClient 是线程安全的。对应到连接池的结构示意图中，整个 API 就是蓝色框包裹的部分。
- 非连接池的 API：一般命名为 XXXConnection，以区分其是基于连接池还是单连接的，而不建议命名为 XXXClient 或直接是 XXX。直接连接方式的 API 基于单一连接，每次使用都需要创建和断开连接，性能一般，且通常不是线程安全的。对应到连接池的结构示意图中，这种形式相当于没有右边连接池那个框，客户端直接连接服务端创建连接。

明确了 SDK 连接池的实现方式后，我们就大概知道了使用 SDK 的最佳实践：

- 如果是分离方式，那么连接池本身一般是线程安全的，可以复用。每次使用需要从连接池获取连接，使用后归还，归还的工作由使用者负责。
- 如果是内置连接池，SDK 会负责连接的获取和归还，使用的时候直接复用客户端。
- 如果 SDK 没有实现连接池（大多数中间件、数据库的客户端 SDK 都会支持连接池），那通常不是线程安全的，而且短连接的方式性能不会很高，使用的时候需要考虑是否自己封装一个连接池。





### 使用连接池务必确保复用

在介绍线程池的时候我们强调过，池一定是用来复用的，否则其使用代价会比每次创建单一对象更大。对连接池来说更是如此，原因如下：

- 创建连接池的时候很**可能一次性创建了多个连接**。
  - 大多数连接池考虑到性能，会在初始化的时候维护一定数量的最小连接（毕竟初始化连接池的过程一般是一次性的），可以直接使用。如果每次使用连接池都按需创建连接池，那么很可能你只用到一个连接，但是创建了 N 个连接。
- 连接池一般会有一些管理模块，也就是连接池的结构示意图中的绿色部分。
  - 举个例子，大多数的连接池都有闲置超时的概念。连接池会检测连接的闲置时间，定期回收闲置的连接，把活跃连接数降到最低（闲置）连接的配置值，减轻服务端的压力。一般情况下，闲置连接由独立线程管理，启动了空闲检测的连接池相当于还会启动一个线程。此外，有些连接池还需要独立线程负责连接保活等功能。因此，**启动一个连接池相当于启动了 N 个线程**。

除了使用代价，**连接池不释放，还可能会引起线程泄露**。



### 连接池的配置不是一成不变的

- 最大连接数不是设置得越大越好。
  - 如果设置得太大，不仅仅是客户端需要耗费过多的资源维护连接，更重要的是由于服务端对应的是多个客户端，每一个客户端都保持大量的连接，会给服务端带来更大的压力。
- 连接池最大连接数设置得太小，很可能会因为获取连接的等待时间太长，导致吞吐量低下，甚至超时无法获取连接。
- 对类似数据库连接池的重要资源进行持续检测，并设置一半的使用量作为报警阈值，出现预警后及时扩容。



## 坑满地的List列表操作



### 使用 Arrays.asList 把数据转换为 List 的三个坑

- 不能直接使用 Arrays.asList 来转换基本类型数组。
- Arrays.asList 返回的 List 不支持增删操作。
  - Arrays.asList 返回的 List 并不是我们期望的 java.util.ArrayList，而是 Arrays 的内部类 ArrayList。
- 对原始数组的修改会影响到我们获得的那个 List。
  - ArrayList 其实是直接使用了原始的数组。



### 使用 List.subList 进行切片操作居然会导致 OOM？







