[**首页**](https://github.com/qdw497874677/myNotes/blob/master/首页检索.md)



# OIS

- 应用层：HTTP、FTP、DNS
- 表示层
- 会话层：RPC、SQL
- 传输层：TCP、UDP
- 网络层：IP
- 数据链路层
- 物理层



# TCP/IP

TCP/IP是一类协议系统。

- 应用层：
  - TELNET（网络远程访问协议）
  - FTP（文件传输协议）
  - HTTP（超文本传输协议）
  - SMTP（简单邮件传输协议）
  - DNS（域名系统）：既可以用TCP，也可以用UDP。会根据数据量的大小选择合适的传输层协议。长度超过512字节时使用TCP。
  - DHCP（动态主机配置协议）：用UDP
  - SNMP（简单网络管理协议）：用UDP
- 传输层
  - TCP（传输控制协议）
  - UDP（用户数据报协议）
- 网络层
  - IP（网际协议）
  - ICMP（网络控制报文协议）
  - IGMP（网际组管理协议）
- 网络接口层（链路层）
  - ARP（地址解析协议）
  - RARP（逆地址解析协议）



# DNS

把主机名转换为ip地址。

通过集群的方式提供服务。

域名的划分有五个类别

- 顶级域名：表示国家或地区或组织。.com  .cn
- 二级域名：个人或组织在因特网上使用的名称。.baidu.
- 三级域名：注册的二级域名的派生的域名。www.



## 域名服务器

- 本地域名服务器：主机发出的DNS查询请求，先发送到本地域名服务器。
- 根域名服务器：知道所有顶级域名服务器的域名和ip地址。
- 顶级域名服务器：负责管理在改顶级域名服务器注册的二级域名。
- 权威域名服务器：负责一个区的域名服务器。

## 解析过程

主机向本地域名服务器查询，一般采用**递归查询**。如果主机询问的本地域名服务器不知道，本地域名服务器以主机的身份向其他根域名服务器继续发出查询请求。最后递归地返回结果。

本地域名服务器向根服务器查询是**迭代查询**。

# HTTP

## 特点

- 支持CS模式，请求都是由客户端发起的。
- 简单快速，客户端请求服务器时，只需传送请求方法和路径
- 灵活，允许传输任意类型的数据对象
- 无连接，每次连接只处理一个请求（HTTP/1.1有了持久连接，连接默认不关闭，可以被多个请求复用）
- 无状态，协议对事务处理没有记忆能力。（HTTP/1.1引入了Cookie技术来保存状态，虽然还是无状态协议）

## 消息结构

### 请求报文

- 报文首部
  - 请求行：第一行，说明了：请求方法、资源标识符（URI）、HTTP版本
  - HTTP首部字段
    - 请求首部字段：
      - Accept：用户代理可处理的媒体类型
      - Accept-Language：优先的语言
      - Authorization：Web认证信息
      - Host：请求资源所在的服务器
      - TE：传输编码的优先级
      - User-Agent：HTTP客户端程序的信息
    - 通用首部字段：请求和响应都会使用的首部字段
      - Cache-Control：控制缓存行为
      - Connection：逐跳首部、连接的管理
      - Date：创建报文的日期时间
      - Via：代理服务器的相关信息
      - Warning：错误通知
    - 实体首部字段：针对报文实体部分使用的首部
  - 其他
- 空行
- 报文主体：

### 响应报文

- 报文首部
  - 状态行：状态码，原因短语，HTTP版本
  - HTTP首部字段
    - 响应首部字段
      - Location：令客户端重定向的URI
    - 通用首部字段
    - 实体首部字段
      - Allow：资源可支持的HTTP方法
      - Content-Encding：实体主体使用的编码方式
      - Content-Language：实体主体的自然语言
      - Content-Langth：实体主体的大小（字节）
  - 其他
- 报文主体：



## 状态码

- 1xx：消息：接收的请求正在处理
- 2xx：成功：请求正常处理完毕
  - 200：表示请求被服务器成功处理。
- 3xx：重定向：需要进行附加操作来完成请求
  - 301：永久重定向。表示请求的资源已经分配了新的URI，以后应该使用新的URI。
  - 302：暂时重定向。表示资源分配了新的URI，希望用户本次用新的URI访问。
  - 304：没有修改。告诉客户端请求的资源没有做修改，可以使用未过期的缓存。
- 4xx：请求错误：服务器无法处理请求
  - 400：表示请求报文中存在语法错误
  - 401：表示发送的请求需要有通过HTTP认证的认证信息，若之前进行过一次请求，表示用户认证失败。**返回401的响应报文必须包含一个适用于被请求资源的www-Authenticate首部字段**，来质问用户信息。
  - 403：服务器拒绝请求，没必要给出理由。（可能是权限不够）
  - 404：服务器上无法找奥请求的资源，也可以表示服务器拒绝请求而不说理由
- 5xx：服务器错误：服务器处理请求出错
  - 500：服务器执行请求时发生错误。
  - 501：服务器不支持请求的功能，无法完成请求
  - 502：bad gateway
  - 503：表示服务器超负载或者正在停机维护。

## HTTP安全性的缺点

- 通信使用明文，内存可能被窃取
- 不验证对方身份，可能遭遇伪装
  - 伪装的web服务器
  - 伪装的客户端
  - DOS攻击（无意义的请求照单全收）
- 无法证明报文的完整性，报文可能被篡改
  - 中间人攻击（MITM）

## HTTPS

HTTP+加密+认证+完整性保护=HTTPS

加密：采用对称与非对称结合的加密。使用非对称加密，处理共享密钥。共享密钥交换完成后，改为对称加密通信。

认证：可以通过证书解决。网站向数字证书认证机构（CA）申请，机构认清身份后，对网站申请的公开密钥做数字签名，将这个数字签名和公钥作为证书发布。

- 服务器：服务器将这份由数字证书认证机构颁发的证书发送给客户端。客户端收到后，对证书上的数字签名进行验证，验证通过表名：一、认证服务器的是真实有效的CA；二、服务器的公钥值得信任。
- 客户端：客户端证书可以确保客户端是服务器意料之内的。

## HTTP和HTTPS的区别

- HTTP是明文传输；HTTPS是基于SSL加密传输。
- HTTP不需要证书；HTTPS需要到CA申请证书。
- HTTP默认端口号为80；HTTPS默认端口号为443。

## SSL的握手过程

1. 第一阶段
   1. 客户端向服务器端请求连接，消息里包含客户端生成的随机数、支持的加密套件、SessionId（第一次没有）和SSL Vsersion信息。
   2. 服务器接受后，会发送一个反馈的hello，消息中包含随机数、选择的加密套件、SessionId
2. 第二阶段：全部由服务器端发送
   1. 发送证书，证书中包含公钥。
   2. 服务器密钥交换（可选），视密钥减缓算法而定。
   3. 证书请求（可选），服务端可能要求客户端自身的认证。
   4. 服务器第二阶段要发的全部发完，第二阶段结束。
3. 第三阶段：客户端发送
   1. 证书（可选），证明自己。
   2. 密钥交换，根据之前的随机数和交换算法生成对称密钥，将生成的密钥通过服务器端的公钥加密，发给服务器端。
   3. 证书验证（可选），如果发送了证书证明自己，还需发送这个，包换一个对从第一条消息以来的所有握手信息的摘要用密钥进行签名。
4. 第四阶段：检验连接，完成握手协议，建立SSL连接
   1. 客户端发送消息，然后再用新的对称密钥和算法发送一个Finished消息，来检验是否成功。
   2. 服务器端同理。



## HTTPS的通信过程

一个HTTPS请求实际上包含了两次HTTP传输

- 客户端向服务器请求连接。发送的信息有协议版本，加密方法。
- 服务器接收到请求，发送给客户端的有证书、公钥、随机数
- 客户端收到后验证证书合法性。验证合法后根据服务端发来的随机数生成一个对称加密的会话密钥，用公钥对这个密钥加密。然后把本次连接开始之后的所有发送的内容的hash值和会话秘钥发送给服务器。
- 服务器收到后，用自己的私钥进行非对称解密，就获取到了这个会话密钥。以后就用这个会话秘钥进行数据传输。



## GET和POST

是HTTP请求类型

- GET一般用于从服务器获取资源；POST有可能改变服务器的资源。
- GET请求的数据添加在url后面（url在HTTP请求头上）；POST请求的数据在请求体中。
- 安全性不同：GET请求可以被缓存、收藏、保存到历史记录中，并且请求明文出现在url里；POST请求的参数一般不会被浏览器保存。
- GET请求只允许ASCII字符；POST请求对数据类型没有要求，也允许二进制数据。
- GET请求传输的数据量小；POST传输的数据量大。
- GET请求在发送过程中会产生一个TCP数据包。浏览器会把http header和data一并发送出去，服务器响应200；POST在发射过程中会产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200。

## 持久连接

浏览一个网页的同时，发送请求获取这个网页的资源，也会去访问别的资源，如果每次都建立TCP连接，会消耗很多资源。

HTTP/1.1和一部分HTTP/1.0提出了**持久连接（HTTP keep-alive**）。持久连接的特点是，只要任意一段没有明确提出断开连接，就保持TCP连接。

持久连接使得多数请求以**管线化**方式发送成为可能。之前发送请求后需要等待收到响应后，才能发送下一个请求。管线化技术出现后，不用等待响应也可以直接发送下一个请求。



## request和response

一个请求传到服务器端的时候，服务器会创建对应的request和response。使用request可以获取请求数据，使用response来完成对客户端的响应。

- request：请求行（HTTP方法、请求目标、HTTP版本）、请求头、请求体（GET请求没有请求体）。
- response：状态行、响应头、响应体。

## Cookie

HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。由于不必保存状态，所以可以减少服务器的CPU和内存的消耗。

为了保存无状态这个特征，同时保存状态，引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie会根据从服务器端发送的响应报文内的一个叫**Set-Cookie**的首部字段信息，通知客户端保存Cookie。当下次客户端往服务器发送请求时，会自动在请求报文中加入Cookie的值并发送。

服务器端发现客户端发送的Cookie后，检查Cookie从哪个客户端发来的，然后对比Cookie中的 记录和服务器上的记录，得到之前的状态信息。



## session 和 cookie 

cookie的主要作用是通过服务端记录用户的状态。

- 存储位置不同：session存在服务器端，存储结构为ConcurrentHashMap；cookie存储在浏览器。
- 安全性不同：session存在服务器安全性比较好；cookie在浏览器存储，可以被用户访问，所以安全性一般。
- 容量和个数限制：cookie有个数和容量限制，根据浏览器不同个数和容量限制不同。容量限制大概在4kB左右。
- 存储的多样性：session可以存储在Redis、数据库、应用程序中；cookie只能存储在浏览器中。



## session的工作原理

在用户完成登录后，服务器会为用户创建一个session。然后把session id发送到客户端，客户端存储到浏览器中的cookie中。用户每次访问服务器都会带着session id，服务器拿到session id后，就可以分辨用户。

- 用户登录成功，服务器创建在session中添加这个用户信息对象。
- 将session在数据结构中的key（sessionid），通过setCookie，返回给客户端。
- 客户端下次访问，cookie带上这个sessionid，在服务器端检查session中是否有这个key。如果有就说明已登录，没有就未登录。（cookie只在当前域名下生效）

客户端也可以不用cookie存储sessionid，可以通过在url上添加sessionid，保证session正常使用。但是降低了安全性。当然也可以对sessionid加密后再传

可能出现的问题：

- 服务器中的session在停止服务后会消失，需要做持久化。
- 因为负载均衡，可能改变服务器，导致session失效。用缓存服务器解决记录用户状态问题。

## Token

cookie需要要求前后端同一个项目。对于前后端分离的情况需要用token来做用户认证。

Token就是一段字符串。用户登录成功时，服务器生成对应的key和用户信息并加密成字符串，将{token:'字符串'}放在相应体中返回给客户端。客户端通过cookie、sessionStorage、localStorage都可以存储。但是在发送请求时不会默认携带，在服务器要求携带认证信息时，会把Token信息放在请求头中的认证信息中。

在之前，服务器需要自己存放一份Session信息，可能会出现一些问题。现在通过Token可以实现服务器自己不用存放Session信息就能实现身份验证。JWT（JSON Web Token）就是这种方式的实现，只要客户端保存了服务器根据Session为客户端生成的Token就可以了。

## JWT

Json Web Token。可以解决传动身份状态验证无法横向扩展的缺点。使用JWT的话，验证成功后会生成带有签名的JSON对象，将它返回给客户端，服务器不用保存会话信息，

**JWT以JSON对象的形式安全传递信息。**因为他是带签名的，因此接受者便可以验证它的真实性。

组成结构：由三个字符串和两个"."组成，没有换行。

1. Header：Json，描述JWT的元数据，定义了生成签名算法以及Token的类型。例如json{"alg":"HS256","typ":"JWT"}
2. Payload（负载）：Json，用来存放实际需要传递的数据。
   1. 标准注册声明：不强制使用
      1. iss：jwt的签发者\发行人
      2. sub：主题
      3. aud：接收方
      4. exp：过期时间
      5. nbf：生效时间
      6. iat：签发时间
      7. jti：唯一身份标识，可以避免重放攻击
   2. 公共声明：这部分可以在客户端解密，所以一般不添加敏感信息，一般添加用户信息和业务信息。
   3. 私有声明：服务器和客户端共同定义的声明，不建议添加敏感信息
3. Signature（签名）：服务器通过Payload、Header和一个秘钥（secret）使用**Header里面制定的签名算法**（默认是HMAC SHA256）生成。

验证流程：

1. 用户向服务器发送登录信息。
2. 服务器验证成功后，根据Header、Payload、secret生成组成JWT的签名，然后组合成JWT作为Token放在相应体中返回给客户端。客户端把Token存放到cookie或者localStorage中。
3. 在服务器需要的时候，把Token带上，一般是放在请求头的Authorization字段中。
4. 服务器检查JWT并从中获取用户相关信息。



## CSRF攻击

**CSRF（Cross Site Request Forgery）**一般被翻译为 **跨站请求伪造** 。简单的理解就是用你的身份去发送一些对你不友好的请求。

在你点击一个链接后，这个链接目的是想利用你的信息发送一些对你不好的请求。如果你的cookie中有链接预想的用户信息，就会被链接用你的用户信息去做不好的事。

而使用**Token**是可以避免CSRF的。因为Token是默认不携带的。





## 基于HTTP的优化

> 解决HTTP的瓶颈：数据有更新，需要在客户端实时更新。

### Ajax

Ajax（异步JavaScript与XML技术）是一种有效利用JavaScript和DOM的操作，以达到局部Web页面替换加载的异步通信手段。

利用Ajax实时从服务器获取内容，有可能导致大量请求产生。

### Comet

一旦服务器有内容更新，Comet不会让请求等待，而是直接给客户端返回响应。通过延迟应答，模拟实现服务器端向客户端推送的功能。

为了实现推送，服务端收到请求后，先将响应挂起，当有内容有更新时再响应客户端。

虽然能做到实时更新，但是一次连接的持续时间变长了，期间为了维持连接会消耗更多资源。

### SPDY

通过协议层面的改动来对HTTP进行根本性的改善。

在TCP/IP的应用层与传输层之间通过新加的会话层来运作，并在通信中使用SSL。SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接，可以照常使用HTTP的功能。

使用SPDY后，HTTP协议额外获得以下功能。

- 多路复用流：通过一个TCP连接，可以无限制处理多个HTTP请求。
- 赋予请求优先级：可以给请求分配优先级顺序。解决因带宽低导致响应变慢的问题。
- 压缩HTTP首部：压缩HTTP请求和响应的首部。
- 推送功能：支持服务器主动向客户端推送数据的功能。
- 服务器提示功能：服务器可以主动提示客户端请求所需的资源

SPDY需要客户端作响应的修改，并且SPDY基本上时值单个域名（IP）的通信多路复用。

### WebSocket

WebSocket解决Ajax和Comet所要解决的问题。它逐渐成为了独立的协议。

Webocket可以让客户端和服务器端之间实现全双工通信。一旦服务器端和客户端建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可以互相发送JSON、XML、HTML或图片等任意格式的数据。

由于是建立在HTTP基础上的协议，因此连接的发起方依然要求是客户端。

主要特点：

- 推送功能：支持服务器端主动推送数据给客户端。
- 减少通信量：Webocket的首部信息很小，通信量也响应减少了。

为了实现Webocket的通信，在建立HTTP连接之后，需要完成一次“握手”的步骤：

- 握手：请求
  - 用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变。
  - Sec-Webocket-Key字段记录握手过程中必不可少的键值
  - Sec-Webocket-Protocol字段记录使用的子协议
- 握手：响应
  - 返回状态码101 Switching Protocols的响应。
  - Sec-Webocket-Accept的字段值是由握手请求中Sec-Webocket-Key的字段值生成的。

成功握手后确立WebSocket连接之后，通信时不再需要HTTP数据帧，而采用WebSocket数据帧。





## 待更新！！！——从输入网址到获得页面的过程

1. 浏览器查询DNS，获取域名对应的IP地址。
   1. 先到浏览器的DNS缓存中查找。
   2. 如果没有到操作系统的DNS缓存中查找。
   3. 如果没有，向本地服务器进行递归查询。
   4. 本地服务器如果没有，本地服务器就会进行一个迭代的查询。
      1. 本地服务器先向一个根域名服务器查询，如果有就返回。
      2. 根域名服务器没有，就返回下一次查询的顶级域名服务器。
      3. 本地服务器向顶级域名服务器查询，如果有返回，没有就被告知去权限服务器查询。
      4. 本地服务器去权限服务器查询，查到主机id返回给浏览器主机。
2. 向服务器请求建立TCP连接
3. 发送HTTP请求
4. 服务器接收到这个请求，映射到特定的方法中处理结果，将结果和视图返回给浏览器
5. 浏览器解析渲染页面：边解析边渲染
   1. 解析HTML文件构建DOM树，然后解析CSS文件构建渲染树。然后开始布局渲染树并将其绘制到屏幕上。



## TCP和UDP

- TCP是面向连接的，提供可靠的交付，支持流量控制，拥塞控制，面向字节流（把报文看成字节流，组织成数据块），每一条TCP连接只能是点对点的。
- UPD是无连接的，尽可能最大交付，没有拥塞控制，面向报文的（不会对应用层传下来的报文进行合并和拆分），支持一对一、多对多、一对多、多对一。



## TCP的三次握手

![img](计算机网络.assets/untitle-1590394126872.png)

客户端发送SYN，服务端回复ACK同时发送SYN，客户端回复ACK。带有SYN必须要ACK回复

A是客户端，B是服务器端。

- B处于监听状态，等待请求到来。
- A向B发送请求连接报文，同步码是1，序号是x。
- B收到后，向A发送确认报文，同步码是1，确认码是1，确认号是x+1，序号是y。
- A收到后，向B发送确认报文，确认码是1，确认号是y+1。

### 为什么要三次

从三个方面分析

- 可以阻止历史重复连接的初始化（首要原因）

假如一个旧的报文比新的报文早到达服务器，服务器做了回复，客户端收到后，判断这是个历史连接，就发送RST报文中断这次连接。如果两次握手，就不能判断当前连接是历史连接。比如客户端发送了一个请求连接报文，超时了，然后又发送一个，服务器端先收到了旧请求然后给了回复，客户端收到后会终止这个旧的连接请求。

- 可以同步双方的初始序列号

另一种说法就是，TCP协议的双方，都要**维护一个序列号**，以标识发出去的数据包，哪些是被对方收到的。序列号是可靠传输的一个关键因素。三次握手的过程也是通信双方告知序列号起始值，并确认对方已经收到了序列号起始值的毕竟步骤。A发送一个序列号，B回复收到，这算确认了A方的起始号；B发送一个序列号，A回复收到，B方的起始号也确认了。结合在一起最少是三次握手。

- 避免资源浪费

为了防止服务器对已经失效的请求建立连接，而造成资源浪费。如果没有三次握手，服务器可能因为网络原因，收到很多同一个客户端发来的请求。双方无法确认到底要连接哪个。所以三次握手就只能来一个连一个。而三次握手之后，服务器就会忽略客户端的其他连接请求了。

### SYN攻击是什么

在第二次握手后，服务器会等待客户端的请求确认。假设攻击者短时间伪造大量不同ip的syn报文，服务器收到后对这个ip回应，但迟迟得不到回应。服务器会对这些请求一一回复并等待回复，对服务器压力很大，会占满服务端的SYN接收队列。

#### 如何避免

- 修改参数，控制队列大小和当队列满时应该怎么处理。比如
  - 设置状态连接最大值
  - 设置超出处理能力时，对新的SYN返回RST，丢弃连接

### 服务器没有收到第三次挥手会怎么办

服务器端：

 第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。

而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.

客户端：

客户端会感知到服务器端发送的信息，从而感知到错误。



## TCP的四次挥手

![img](计算机网络.assets/untitle.png)

双方都可以主动断开连接。

客户端发送FIN，服务器端回复ACK，之后传完数据发送FIN（这里和前面的ACK分开发送，所以多了一次挥手），客户端回复ACK。

A是客户端，B是服务器端。

- A向B发送释放连接报文，结束码1，序号x。
- B收到后，向A发送确认报文，确认码1，确认号x+1，序号y。
- B接着向A发送剩下的数据。传输完成后，向A发送释放连接报文，结束码1，确认码1，确认号x+1，序号z。
- A收到释放报文，向B发送确认报文，确认码1，确认号z+1，序号x+1。然后进入TIME-WAIT状态，等待2MSL时间后，释放连接。

### 为什么四次

因为TCP连接是全双工的，每个方向都必须单独进行关闭。确保两个方向都不需要传输，所以双方都要发送一个表示结束的报文。因为服务器在收到释放请求后，需要把剩余的数据传完，比三次多一次就是为了传完数据。

### 

### 为什么需要TIME-WAIT

- 让本次连接的数据在网络中消失（包括自己发送的ACK和对方的重发报文之和），防止下次连接到旧数据
- 保证连接正确关闭。确保最后的ACK让被动关闭防接收，如果对方没有接收到，会在2MSL时间内重发FIN报文。

### 为什么进入TIME-WAIT等待时间时2MSL

MSL是报文最大生存时间，任何报文在网络上存在的最长时间。

确保发送方发送的最后一个ACK确认请求能够到达。如果接收方没收到ACK，会重发FIN，2MSL的时间可以接收到被动断开连接的重发FIN报文。



## TCP如何可供可靠的数据传输

- 字节编号机制

  - TCP数据中每一个字节都要编号。TCP数据是有序的，接收完要按序组装然后交付。

- 数据段确认机制

  - 发送数据后会收到接收方的确认号，确认号之前的数据表明已经接收到了。

- 超时重传机制

  - 每发送一个数据段就会启动一个超时重传计时器，时间内没有收到确认就会重新传输。

- 数据包校验

- 流量控制

  



## TCP如何实现流量控制

使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区溢出。

接收方会维护一个接收窗口，大小根据自己的资源情况动态调整。通过确认请求通知对方自己的窗口大小。

发送窗口的上限为接收窗口和拥塞窗口中的最小值。

接收窗口表明接收方的接收能力；拥塞窗口表明网络的传输能力。

过程：接收方每次收到数据包，在发送确认报文时，同时告诉发送方自己的缓存区还剩多少时空闲的，我们把换缓存的剩余大小称之为接收窗口大小。

发送发收到之后，会调整自己的发送速率，也就是调整自己的发送窗口的大小。当发送方收到接收窗口大小为0时，发送方就会停止发送数据，防止出现大量丢包的情况。停止发送后，同时开启一个定时器，每隔一段时间就发送一个测试报文去询问接收方是否可以继续发送数据，如果可以接收方就告诉此时的接收窗口大小。如果还是为0，发送方就刷新定时器。



## TCP如何实现拥塞控制

四个算法：

- 慢开始：刚开始发送数据时，先把拥塞窗口设置为一个单位。发送方发送一个窗口数量的报文段。当接收到所有报文段的确认报文后，窗口就会增大一倍，然后接着发送一个窗口数量的报文段。每次发送报文的数量是指数上升的。
- 拥塞避免：拥塞窗口到达慢开始上限时，改为线性增加窗口大小。每传发送一个窗口数量的报文段，并收到所有确认后，窗口只增加一。如果前两个阶段出现在计时器时间内没有接收到确认的情况，发送方就认为发生了拥塞，就会把慢开始上限设为当前窗口大小的一半，窗口大小设为1，重新开始慢开始。
- 快重传：有时候没有收到确认可能是报文段在网络中丢失，而不是拥塞。通过快重传可以一定程度上避免误认为是拥塞的情况。当接收方收到不是按序到达的报文后，就会立刻发送对缺失报文段的重复确认报文。发送方收到三个以后，就会把缺失的报文段重新发送。
- 快恢复：发送方首收到三个重复确认报文后，把慢开始上限和拥塞窗口都改为当前拥塞窗口的一半，然后执行拥塞避免。



## 拆包和粘包

tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：

- 发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；
- 接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。



# Socket

redis用epoll、nginx用epoll

