[**首页**](https://github.com/qdw497874677/myNotes/blob/master/首页检索.md)



# OIS

- 应用层：HTTP、FTP、DNS
- 表示层
- 会话层：RPC、SQL
- 传输层：TCP、UDP
- 网络层：IP
- 数据链路层
- 物理层



# TCP/IP

TCP/IP是一类协议系统。

- 应用层：
  - TELNET、
  - FTP、
  - HTTP、
  - SMTP、
  - DNS
- 传输层
  - TCP
  - UDP
- 网络层
  - IP
  - ICMP
  - ARP
  - RARP
- 网络接口层



# HTTP

## header

- Cache-Control：可以控制缓存行为
- Accept：用于补充附加信息。通知服务器自己需要什么类型的，html文本图片
- Authorization：填写认证信息。通常在接收到返回的401状态码后，把字段内容加入请求
- 



## 状态码

- 1xx：消息
- 2xx：成功
  - 200：成功请求
- 3xx：重定向
  - 301：永久重定向
  - 302：暂时重定向
- 4xx：请求错误
  - 401：要求身份验证
  - 403：服务器拒绝请求
  - 404：服务器找不到请求的页面
- 5xx：服务器错误
  - 500：服务器内部错误
  - 501：服务器不支持请求的功能，无法完成请求

## HTTP安全性的缺点

- 通信使用明文，内存可能被窃取
- 不验证对方身份，可能遭遇伪装
  - 伪装的web服务器
  - 伪装的客户端
  - DOS攻击（无意义的请求照单全收）
- 无法证明报文的完整性，报文可能被篡改
  - 中间人攻击（MITM）

## HTTPS

HTTP+加密+认证+完整性保护=HTTPS

加密：采用对称与非对称结合的加密。使用非对称加密，处理共享密钥。共享密钥交换完成后，改为对称加密通信。

认证：可以通过证书解决。网站向数字证书认证机构（CA）申请，机构认清身份后，对网站申请的公开密钥做数字签名，将这个数字签名和公钥作为证书发布。

- 服务器：服务器将这份由数字证书认证机构颁发的证书发送给客户端。客户端收到后，对证书上的数字签名进行验证，验证通过表名：一、认证服务器的是真实有效的CA；二、服务器的公钥值得信任。
- 客户端：客户端证书可以确保客户端是服务器意料之内的。

## HTTP和HTTPS的区别

- HTTP是明文传输；HTTPS是基于SSL加密传输。
- HTTP不需要证书；HTTPS需要到CA申请证书。
- HTTP默认端口号为80；HTTPS默认端口号为443。

## SSL的握手过程

1. 第一阶段
   1. 客户端向服务器端请求连接，消息里包含客户端生成的随机数、支持的加密套件、SessionId（第一次没有）和SSL Vsersion信息。
   2. 服务器接受后，会发送一个反馈的hello，消息中包含随机数、选择的加密套件、SessionId
2. 第二阶段：全部由服务器端发送
   1. 发送证书，证书中包含公钥。
   2. 服务器密钥交换（可选），视密钥减缓算法而定。
   3. 证书请求（可选），服务端可能要求客户端自身的认证。
   4. 服务器第二阶段要发的全部发完，第二阶段结束。
3. 第三阶段：客户端发送
   1. 证书（可选），证明自己。
   2. 密钥交换，根据之前的随机数和交换算法生成对称密钥，将生成的密钥通过服务器端的公钥加密，发给服务器端。
   3. 证书验证（可选），如果发送了证书证明自己，还需发送这个，包换一个对从第一条消息以来的所有握手信息的摘要用密钥进行签名。
4. 第四阶段：检验连接，完成握手协议，建立SSL连接
   1. 客户端发送消息，然后再用新的对称密钥和算法发送一个Finished消息，来检验是否成功。
   2. 服务器端同理。



## HTTPS的通信过程

一个HTTPS请求实际上包含了两次HTTP传输

- 客户端向服务器请求连接。
- 服务器接收到请求，将证书和公钥发给客户端。
- 客户端收到后验证证书合法性。验证合法后随机生成一个对称加密的会话密钥，用公钥对这个密钥加密。将这些信息发送给服务器。
- 服务器收到后，用自己的私钥进行非对称解密，就获取到了这个会话密钥。以后就用这个会话秘钥进行数据传输。



## GET和POST

是HTTP请求类型

- GET一般用于从服务器获取资源；POST有可能改变服务器的资源。
- GET请求的数据添加在url后面（url在HTTP请求头上）；POST请求的数据在请求体中。
- 安全性不同：GET请求可以被缓存、收藏、保存到历史记录中，并且请求明文出现在url里；POST请求的参数一般不会被浏览器保存。
- GET请求只允许ASCII字符；POST请求对数据类型没有要求，也允许二进制数据。
- GET请求传输的数据量小；POST传输的数据量大。
- GET请求在发送过程中会产生一个TCP数据包。浏览器会把http header和data一并发送出去，服务器响应200；POST在发射过程中会产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200。

## 持久连接

浏览一个网页的同时，发送请求获取这个网页的资源，也会去访问别的资源，如果每次都建立TCP连接，会消耗很多资源。

HTTP/1.1和一部分HTTP/1.0提出了**持久连接（HTTP keep-alive**）。持久连接的特点是，只要任意一段没有明确提出断开连接，就保持TCP连接。

持久连接使得多数请求以**管线化**方式发送成为可能。之前发送请求后需要等待收到响应后，才能发送下一个请求。管线化技术出现后，不用等待响应也可以直接发送下一个请求。



## request和response

一个请求传到服务器端的时候，服务器会创建对应的request和response。使用request可以获取请求数据，使用response来完成对客户端的响应。

- request：请求行（HTTP方法、请求目标、HTTP版本）、请求头、请求体（GET请求没有请求体）。
- response：状态行、响应头、响应体。

## Cookie

HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。由于不必保存状态，所以可以减少服务器的CPU和内存的消耗。

为了保存无状态这个特征，同时保存状态，引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie会根据从服务器端发送的响应报文内的一个叫**Set-Cookie**的首部字段信息，通知客户端保存Cookie。当下次客户端往服务器发送请求时，会自动在请求报文中加入Cookie的值并发送。

服务器端发现客户端发送的Cookie后，检查Cookie从哪个客户端发来的，然后对比Cookie中的 记录和服务器上的记录，得到之前的状态信息。



## session 和 cookie 

cookie的主要作用是通过服务端记录用户的状态。

- 存储位置不同：session存在服务器端，存储结构为ConcurrentHashMap；cookie存储在浏览器。
- 安全性不同：session存在服务器安全性比较好；cookie在浏览器存储，可以被用户访问，所以安全性一般。
- 容量和个数限制：cookie有个数和容量限制，根据浏览器不同个数和容量限制不同。容量限制大概在4kB左右。
- 存储的多样性：session可以存储在Redis、数据库、应用程序中；cookie只能存储在浏览器中。



## session的工作原理

在用户完成登录后，服务器会为用户创建一个session。然后把session id发送到客户端，客户端存储到浏览器中的cookie中。用户每次访问服务器都会带着session id，服务器拿到session id后，就可以分辨用户。

- 用户登录成功，服务器创建在session中添加这个用户信息对象。
- 将session在数据结构中的key（sessionid），通过setCookie，返回给客户端。
- 客户端下次访问，cookie带上这个sessionid，在服务器端检查session中是否有这个key。如果有就说明已登录，没有就未登录。（cookie只在当前域名下生效）

客户端也可以不用cookie存储sessionid，可以通过在url上添加sessionid，保证session正常使用。但是降低了安全性。当然也可以对sessionid加密后再传

可能出现的问题：

- 服务器中的session在停止服务后会消失，需要做持久化。
- 因为负载均衡，可能改变服务器，导致session失效。用缓存服务器解决记录用户状态问题。

## Token

cookie需要要求前后端同一个项目。对于前后端分离的情况需要用token来做用户认证。

Token就是一段字符串。用户登录成功时，服务器生成对应的key和用户信息并加密成字符串，将{token:'字符串'}放在相应体中返回给客户端。客户端通过cookie、sessionStorage、localStorage都可以存储。但是在发送请求时不会默认携带，在服务器要求携带认证信息时，会把Token信息放在请求头中的认证信息中。

在之前，服务器需要自己存放一份Session信息，可能会出现一些问题。现在通过Token可以实现服务器自己不用存放Session信息就能实现身份验证。JWT（JSON Web Token）就是这种方式的实现，只要客户端保存了服务器根据Session为客户端生成的Token就可以了。

**JWT本质上就是一段签名的JSON格式的数据。**因为他是带签名的，因此接受者便可以验证它的真实性。由三部分组成：

1. Header：标书JWT的元数据，定义了生成签名算法以及Token的类型。
2. Payload（负载）：用来存放实际需要传递的数据。
3. Signature（签名）：服务器通过Payload、Header和一个秘钥（secret）使用Header里面制定的签名算法（默认是HMAC SHA256）生成。

验证流程：

1. 用户想服务器发送登录信息。
2. 服务器验证成功后，根据Header、Payload、secret生成组成JWT的签名，然后组合成JWT作为Token放在相应体中返回给客户端。客户端把Token存放到cookie或者localStorage中。
3. 在服务器需要的时候，把Token带上，一般是放在请求头的Authorization字段中。
4. 服务器检查JWT并从中获取用户相关信息。



## CSRF攻击

**CSRF（Cross Site Request Forgery）**一般被翻译为 **跨站请求伪造** 。简单的理解就是用你的身份去发送一些对你不友好的请求。

在你点击一个链接后，这个链接目的是想利用你的信息发送一些对你不好的请求。如果你的cookie中有链接预想的用户信息，就会被链接用你的用户信息去做不好的事。

而使用**Token**是可以避免CSRF的。因为Token是默认不携带的。





## 基于HTTP的优化

> 解决HTTP的瓶颈：数据有更新，需要在客户端实时更新。

### Ajax

Ajax（异步JavaScript与XML技术）是一种有效利用JavaScript和DOM的操作，以达到局部Web页面替换加载的异步通信手段。

利用Ajax实时从服务器获取内容，有可能导致大量请求产生。

### Comet

一旦服务器有内容更新，Comet不会让请求等待，而是直接给客户端返回响应。通过延迟应答，模拟实现服务器端向客户端推送的功能。

为了实现推送，服务端收到请求后，先将响应挂起，当有内容有更新时再响应客户端。

虽然能做到实时更新，但是一次连接的持续时间变长了，期间为了维持连接会消耗更多资源。

### SPDY

通过协议层面的改动来对HTTP进行根本性的改善。

在TCP/IP的应用层与传输层之间通过新加的会话层来运作，并在通信中使用SSL。SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接，可以照常使用HTTP的功能。

使用SPDY后，HTTP协议额外获得以下功能。

- 多路复用流：通过一个TCP连接，可以无限制处理多个HTTP请求。
- 赋予请求优先级：可以给请求分配优先级顺序。解决因带宽低导致响应变慢的问题。
- 压缩HTTP首部：压缩HTTP请求和响应的首部。
- 推送功能：支持服务器主动向客户端推送数据的功能。
- 服务器提示功能：服务器可以主动提示客户端请求所需的资源

SPDY需要客户端作响应的修改，并且SPDY基本上时值单个域名（IP）的通信多路复用。

### WebSocket

WebSocket解决Ajax和Comet所要解决的问题。它逐渐成为了独立的协议。

Webocket可以让客户端和服务器端之间实现全双工通信。一旦服务器端和客户端建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可以互相发送JSON、XML、HTML或图片等任意格式的数据。

由于是建立在HTTP基础上的协议，因此连接的发起方依然要求是客户端。

主要特点：

- 推送功能：支持服务器端主动推送数据给客户端。
- 减少通信量：Webocket的首部信息很小，通信量也响应减少了。

为了实现Webocket的通信，在建立HTTP连接之后，需要完成一次“握手”的步骤：

- 握手：请求
  - 用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变。
  - Sec-Webocket-Key字段记录握手过程中必不可少的键值
  - Sec-Webocket-Protocol字段记录使用的子协议
- 握手：响应
  - 返回状态码101 Switching Protocols的响应。
  - Sec-Webocket-Accept的字段值是由握手请求中Sec-Webocket-Key的字段值生成的。

成功握手后确立WebSocket连接之后，通信时不再需要HTTP数据帧，而采用WebSocket数据帧。





## 从输入网址到获得页面的过程

1. 浏览器查询DNS，获取域名对应的IP地址。
   1. 先到浏览器的DNS缓存中查找。
   2. 如果没有到操作系统的DNS缓存中查找。
   3. 如果没有，向本地服务器进行递归查询。
   4. 本地服务器如果没有，本地服务器就会迭代查询。
      1. 本地服务器先向一个根域名服务器查询
      2. 根域名服务器查询告诉本地服务器下一次查询的顶级域名服务器。
      3. 本地服务器向顶级域名服务器查询，被告知去权限服务器查询。
      4. 本地服务器去权限服务器查询，查到主机id返回给浏览器主机。
2. 向服务器请求建立TCP连接
3. 发送HTTP请求
4. 服务器接收到这个请求，映射到特定的方法中处理结果，将结果和视图返回给浏览器
5. 浏览器解析，获取静态资源，渲染页面。



## TCP和UDP

- TCP是面向连接的，提供可靠的交付，支持流量控制，拥塞控制，面向字节流（把报文看成字节流，组织成数据块），每一条TCP连接只能是点对点的。
- UPD是无连接的，尽可能最大交付，没有拥塞控制，面向报文的（不会对应用层传下来的报文进行合并和拆分），支持一对一、多对多、一对多、多对一。



## TCP的三次握手

![img](计算机网络.assets/untitle-1590394126872.png)

A是客户端，B是服务器端。

- B处于监听状态，等待请求到来。
- A向B发送请求连接报文，同步码是1，序号是x。
- B收到后，向A发送确认报文，同步码是1，确认码是1，确认号是x+1，序号是y。
- A收到后，向B发送确认报文，确认码是1，确认号是y+1。

### 为什么要三次

为了防止服务器对已经失效的请求建立连接。如果没有三次握手，服务器可能因为网络原因，收到很多同一个客户端发来的请求。双方无法确认到底要连接哪个。而三次握手之后，服务器就会忽略客户端的其他连接请求了。

另一种说法就是，TCP协议的双方，都要维护一个序列号，以标识发出去的数据包，哪些是被对方收到的。三次握手的过程也是通信双方告知序列号起始值，并确认对方已经收到了序列号起始值的毕竟步骤。A发送一个序列号，B回复收到，这算确认了A方的起始号；B发送一个序列号，A回复收到，B方的起始号也确认了。结合在一起最少是三次握手。

### SYN攻击是什么

在第二次握手后，服务器等待客户端的请求确认阶段，客户端向服务器发送大量随机源地址的连接请求。服务器会对这些请求一一回复并等待回复，对服务器压力很大。

### 服务器没有收到第三次挥手会怎么办

服务器端：

 第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。

而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.

客户端：

客户端会感知到服务器端发送的信息，从而感知到错误。



## TCP的四次挥手

![img](计算机网络.assets/untitle.png)

A是客户端，B是服务器端。

- A向B发送释放连接报文，结束码1，序号x。
- B收到后，向A发送确认报文，确认码1，确认号x+1，序号y。
- B接着向A发送剩下的数据。传输完成后，向A发送释放连接报文，结束码1，确认码1，确认号x+1，序号z。
- A收到释放报文，向B发送确认报文，确认码1，确认号z+1，序号x+1。然后进入TIME-WAIT状态，等待2MSL时间后，释放连接。

### 为什么四次

因为TCP连接是全双工的，每个方向都必须单独进行关闭。确保两个方向都不需要传输，所以双方都要发送一个表示结束的报文。因为服务器在收到释放请求后，需要把剩余的数据传完，比三次多一次就是为了传完数据。

### 为什么进入TIME-WAIT

- 确保自己发送的最后一个确认请求能够到达B。
- 让本次连接的数据在网络中消失，防止下次连接到旧数据。



## TCP如何可供可靠的数据传输

- 字节编号机制

  - TCP数据中每一个字节都要编号。TCP数据是有序的，接收完要按序组装然后交付。

- 数据段确认机制

  - 发送数据后会收到接收方的确认号，确认号之前的数据表明已经接收到了。

- 超时重传机制

  - 每发送一个数据段就会启动一个超时重传计时器，时间内没有收到确认就会重新传输。

- 数据包校验

- 流量控制

  



## TCP如何实现流量控制

使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区溢出。

接收方会维护一个接收窗口，大小根据自己的资源情况动态调整。通过确认请求通知对方自己的窗口大小。

发送窗口的上限为接收窗口和拥塞窗口中的最小值。

接收窗口表明接收方的接收能力；拥塞窗口表明网络的传输能力。

过程：接收方每次收到数据包，在发送确认报文时，同时告诉发送方自己的缓存区还剩多少时空闲的，我们把换缓存的剩余大小称之为接收窗口大小。

发送发收到之后，会调整自己的发送速率，也就是调整自己的发送窗口的大小。当发送方收到接收窗口大小为0时，发送方就会停止发送数据，防止出现大量丢包的情况。停止发送后，同时开启一个定时器，每隔一段时间就发送一个测试报文去询问接收方是否可以继续发送数据，如果可以接收方就告诉此时的接收窗口大小。如果还是为0，发送方就刷新定时器。



## TCP如何实现拥塞控制

四个算法：

- 慢开始：刚开始发送数据时，先把拥塞窗口设置为一个单位。发送方发送一个窗口数量的报文段。当接收到所有报文段的确认报文后，窗口就会增大一倍，然后接着发送一个窗口数量的报文段。每次发送报文的数量是指数上升的。
- 拥塞避免：拥塞窗口到达慢开始上限时，改为线性增加窗口大小。每传发送一个窗口数量的报文段，并收到所有确认后，窗口只增加一。如果前两个阶段出现在计时器时间内没有接收到确认的情况，发送方就认为发生了拥塞，就会把慢开始上限设为当前窗口大小的一半，窗口大小设为1，重新开始慢开始。
- 快重传：有时候没有收到确认可能是报文段在网络中丢失，而不是拥塞。通过快重传可以一定程度上避免误认为是拥塞的情况。当接收方收到不是按序到达的报文后，就会立刻发送对缺失报文段的重复确认报文。发送方收到三个以后，就会把缺失的报文段重新发送。
- 快恢复：发送方首收到三个重复确认报文后，把慢开始上限和拥塞窗口都改为当前拥塞窗口的一半，然后执行拥塞避免。



## 拆包和粘包

tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：

- 发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；
- 接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。



# Socket

redis用epoll、nginx用epoll

