

# 准备

## Redis





## MySQL

用8，设置mysql的默认时区

![image-20200823003520638](优惠券项目.assets/image-20200823003520638.png)

## Kafka

### 消息系统

- 点对点消息系统
- 发布订阅消息系统

![image-20200823225848666](优惠券项目.assets/image-20200823225848666.png)

Kafka是一个分布式的发布订阅消息系统

![image-20200823231037874](优惠券项目.assets/image-20200823231037874.png)

- Topic：划分数据的类
- partition：每个Topic至少有一个partition。同一个partition里的数据是有序的，不同partition的数据可能是无序的，发送的消息可能进入p1或者p2
- Brokers：一个集群有多台服务器，一个服务器有一个Brokers，存储Topic中的数据，来维护负载均衡。
- producer：数据发布者，将消息发送到Topic，Brokers接收到消息后，把消息追加到partition中
- consumer：消费者，可以消费多个Topic中的数据。多个消费者可以组成消费者组。



### 安装

下载压缩包

打开config文件夹中server.properties

- broker.id：集群中唯一标识，这里默认就好
  - ![image-20200830002705532](优惠券项目.assets/image-20200830002705532.png)
- log.dirs：日志地址，根据需求自己修改
  - ![image-20200830002645796](优惠券项目.assets/image-20200830002645796.png)



![image-20200830002729653](优惠券项目.assets/image-20200830002729653.png)

- 先启动zk
- 启动kafka-server
- 创建topic
  - bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic first-kafka-topic
  - ![image-20200830003408049](优惠券项目.assets/image-20200830003408049.png)
- 查看topic
  - bin/kafka-topics.sh --list --zookeeper localhost:2181
- 启动消费者
  - bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first-kafka-topic --from-beginning
- 启动生产者
  - bin/kafka-console-producer.sh --broker-list localhost:9092 --topic first-kafka-topic
  - ![image-20200830003918464](优惠券项目.assets/image-20200830003918464.png)



### 生产者消费者

![image-20200830004055871](优惠券项目.assets/image-20200830004055871.png)

消息中key的作用

- 提供描述消息的额外信息
- 决定消息写入哪个分区，相同key的消息肯定会分配到同一个分区



![image-20200830004400321](优惠券项目.assets/image-20200830004400321.png)

一个topic中的分区只会消费一次，不管消费者组中有多少个消费者

![image-20200830004643083](优惠券项目.assets/image-20200830004643083.png)

消费者组中消费者数量应该小于一个topic中分区的数量

![image-20200830004725152](优惠券项目.assets/image-20200830004725152.png)



### docker中安装



# Springboot相关



# SpringCloud

## 项目结构

- coupon：总的微服务系统的父模块
  - eureka：基础组件
  - gateway：基础组件
  - service：功能微服务的父模块
    - common

父模块的pom中要设置打包类型为pom

## Eureka

### 介绍

注册中心

两个核心功能

- Service Registry 服务注册
- Service Discovery 服务发现

![Eureka 的基本架构](优惠券项目.assets/c5ab9976ly1fyto185hnwj213g0fw764.jpg)

包含三个组件

- Eureka Server：提供服务注册与发现
- Eureka Client
  - Service Provider：服务提供方。将自身服务注册到Eureka Server上，让其他服务消费方能够找到当前服务。服务注册、心跳续约（告诉Server自己还活着）、下线（自己要下线，让Server删除自己的原信息）
  - Service Consumer：服务消费方，从Eureka Server上获取服务注册信息

Eureka用一个map管理原信息

~~~java
// 第一个key存储服务名称，第二个key存储实例名称，value表示实例的信息
ConcurrentHashMap<String,Map<String,Lease<InstanceInfo>>>
~~~

元信息包含：端口，服务健康信息，续约信息等。

### 创建一个Eureka应用

引入依赖

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>imooc-coupon</artifactId>
        <groupId>com.imooc.coupon</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>

    <artifactId>coupon-eureka</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <!-- 模块名及描述信息 -->
    <name>coupon-eureka</name>
    <description>Spring Cloud Eureka For Coupon</description>

    <!-- eureka server: 提供服务发现与服务注册 -->
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
    </dependencies>

    <!--
        SpringBoot的Maven插件, 能够以Maven的方式为应用提供SpringBoot的支持，可以将
        SpringBoot应用打包为可执行的jar或war文件, 然后以通常的方式运行SpringBoot应用
     -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>


</project>
~~~



启动类，注意多了个Eureka的注解

~~~java
@EnableEurekaServer
@SpringBootApplication
public class EurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
~~~

配置application.yml

~~~yml
spring:
  application:
    name: coupon-eureka

server:
  port: 8000

eureka:
  instance:
    hostname: localhost
  client:
    # 标识是否从 Eureka Server 获取注册信息, 默认是 true. 如果这是一个单节点的 Eureka Server
    # 不需要同步其他节点的数据, 设置为 false
    fetch-registry: false
    # 是否将自己注册到 Eureka Server, 默认是 true. 由于当前应用是单节点的 Eureka Server
    # 需要设置为 false
    register-with-eureka: false
    # 设置 Eureka Server 所在的地址, 查询服务和注册服务都需要依赖这个地址
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
  server:
    enable-self-preservation: false
#    renewal-percent-threshold: 0.45
~~~



本地模拟多实例集群

配置文件

~~~yml
spring:
  application:
    name: coupon-eureka
  profiles: server1
server:
  port: 8000
eureka:
  instance:
  # eureka不允许单机多实例，同一个ip不通过，这里用用host
    hostname: server1
    prefer-ip-address: false
  client:
    service-url:
      defaultZone: http://server2:8001/eureka/,http://server3:8002/eureka/

---
spring:
  application:
    name: coupon-eureka
  profiles: server2
server:
  port: 8001
eureka:
  instance:
    hostname: server2
    prefer-ip-address: false
  client:
    service-url:
      defaultZone: http://server1:8000/eureka/,http://server3:8002/eureka/

---
spring:
  application:
    name: coupon-eureka
  profiles: server3
server:
  port: 8002
eureka:
  instance:
    hostname: server3
    prefer-ip-address: false
  client:
    service-url:
      defaultZone: http://server1:8000/eureka/,http://server2:8001/eureka/

~~~

maven打包

~~~bash
mvn clean package -Dmaven.test.skip=true -U
~~~

进入项目target，找到eureka的jar包，根据不同配置启动三个eureka

~~~bash
java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active=server1
java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active=server2
java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active=server3

~~~



## Zuul

### 介绍

是一个API 网关服务器，本质上就是一个Web Servlet应用

提供了**负载均衡，反向代理，动态路由，监控，请求转发**等服务。实现的核心就是**过滤器**。

微服务系统中的各种微服务往往不直接开放给调用者，而是通过一个服务网关根据请求url，记性请求转发。

![Eureka 的基本架构](优惠券项目.assets/c5ab9976ly1fyto185hnwj213g0fw764.jpg)





![image-20200907204400273](优惠券项目.assets/image-20200907204400273.png)

### 过滤器类型

Zuul中定义了四种标准的过滤器类型。还支持自定义过滤器。

- pre filters：请求在被路由之前调用
- routing filters：路由请求时调用
- post filters：在rount和error过滤器之后被调用
- error filters：处理请求时发生错误时调用



自定义Zuul过滤器

需要继承ZuulFilter，并实现四个抽象方法

- filterType：对应Zuul生命周期的四个阶段
- filterOrder：过滤器的优先级，数字越小优先级越高
- shouldFilter：返回true就执行run方法
- run：过滤逻辑





### 搭建网关服务

依赖

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>imooc-coupon</artifactId>
        <groupId>com.imooc.coupon</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>

    <artifactId>coupon-gateway</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <!-- 模块名及描述信息 -->
    <name>coupon-gateway</name>
    <description>Spring Cloud Gateway For Coupon</description>

    <dependencies>
        <!--
            Eureka 客户端, 客户端向 Eureka Server 注册的时候会提供一系列的元数据信息, 例如: 主机, 端口, 健康检查url等
            Eureka Server 接受每个客户端发送的心跳信息, 如果在某个配置的超时时间内未接收到心跳信息, 实例会被从注册列表中移除
        -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!-- 服务网关 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
        </dependency>
        <!-- apache 工具类 -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>1.3.2</version>
        </dependency>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>16.0</version>
        </dependency>
    </dependencies>

    <!--
        SpringBoot的Maven插件, 能够以Maven的方式为应用提供SpringBoot的支持，可以将
        SpringBoot应用打包为可执行的jar或war文件, 然后以通常的方式运行SpringBoot应用
     -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
~~~



启动类

两个新注解

~~~java
/**
 * <h1>网关应用启动入口</h1>
 * 1. @EnableZuulProxy 标识当前的应用是 Zuul Server
 * 2. @SpringCloudApplication 组合了 SpringBoot 应用 + 服务发现 + 熔断
 */
@EnableZuulProxy
@SpringCloudApplication
public class ZuulGatewayApplication {

    public static void main(String[] args) {

        SpringApplication.run(ZuulGatewayApplication.class, args);
    }
}

~~~

配置

~~~yml
server:
  port: 9000

spring:
  application:
    name: coupon-gateway

eureka:
  client:
    service-url:
      defaultZone: http://server1:8000/eureka/

zuul:
  prefix: /imooc
  routes:
    # 优惠券模板微服务路由配置定义
    template:
      path: /coupon-template/**
      serviceId: eureka-client-coupon-template
      strip-prefix: false
    # 优惠券分发微服务路由配置定义
    distribution:
      path: /coupon-distribution/**
      serviceId: eureka-client-coupon-distribution
      strip-prefix: false
    # 优惠券结算微服务路由配置定义
    settlement:
      path: /coupon-settlement/**
      serviceId: eureka-client-coupon-settlement
      strip-prefix: false
  host:
    connect-timeout-millis: 15000
    socket-timeout-millis: 60000

ribbon:
  ConnectTimeout: 15000
  ReadTimeout: 15000

~~~

#### 编写抽象过滤器

要继承ZuulFilter

ZuulFilter中主要四个需要实现的方法

- public abstract String filterType();确定过滤器的类型，不同类型的过滤器执行点不同
- public abstract int filterOrder();确定同类型过滤器的**执行顺序**
- boolean shouldFilter();返回true就执行run方法。
- Object run() throws ZuulException;run为过滤器主要逻辑

在这个继承ZuulFilter的抽血过滤器中，先只实现shouldFilter和run。对于针对具体类型的过滤器，再通过继承去实现。

~~~java
package com.imooc.coupon.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;

/**
 * <h1>通用的抽象过滤器类</h1>
 * Created by Qinyi.
 */
public abstract class AbstractZuulFilter extends ZuulFilter {

    // 用于在过滤器之间传递消息, 数据保存在每个请求的 ThreadLocal 中
    // 扩展了 Map
    RequestContext context;

    private final static String NEXT = "next";

    /**
     * a "true" return from this method means that the run() method should be invoked
     *
     * @return true if the run() method should be invoked. false will not invoke the run() method
     */
    @Override
    public boolean shouldFilter() {

        RequestContext ctx = RequestContext.getCurrentContext();
        return (boolean) ctx.getOrDefault(NEXT, true);
    }

    /**
     * if shouldFilter() is true, this method will be invoked. this method is the core method of a ZuulFilter
     *
     * @return Some arbitrary artifact may be returned. Current implementation ignores it.
     * @throws ZuulException if an error occurs during execution.
     */
    @Override
    public Object run() throws ZuulException {

        context = RequestContext.getCurrentContext();
        return cRun();
    }

    protected abstract Object cRun();

    Object fail(int code, String msg) {

        context.set(NEXT, false);
        context.setSendZuulResponse(false);
        context.getResponse().setContentType("text/html;charset=UTF-8");
        context.setResponseStatusCode(code);
        context.setResponseBody(String.format("{\"result\": \"%s!\"}", msg));

        return null;
    }

    Object success() {

        context.set(NEXT, true);

        return null;
    }
}

~~~

创建对应类型的抽象过滤器类，这样可以把一些通用的部分复用。

~~~java
package com.imooc.coupon.filter;

import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;

/**
 * Created by Qinyi.
 */
public abstract class AbstractPostZuulFilter extends AbstractZuulFilter {

    /**
     * to classify a filter by type. Standard types in Zuul are "pre" for pre-routing filtering,
     * "route" for routing to an origin, "post" for post-routing filters, "error" for error handling.
     * We also support a "static" type for static responses see  StaticResponseFilter.
     * Any filterType made be created or added and run by calling FilterProcessor.runFilters(type)
     *
     * @return A String representing that type
     */
    @Override
    public String filterType() {
        return FilterConstants.POST_TYPE;
    }
}

~~~

#### 自定义Token过滤器

他是在过滤器的最前面，所以是pre类型

继承pre抽象类，去重写实现run和filterOrder

这里具体的验证逻辑就不写了，大概流程是这样的

~~~java
package com.imooc.coupon.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;

/**
 * <h1>校验请求中传递的 Token</h1>
 * Created by Qinyi.
 */
@Slf4j
//@Component
public class TokenFilter extends AbstractPreZuulFilter {

    @Override
    protected Object cRun() {

        HttpServletRequest request = context.getRequest();
        log.info(String.format("%s request to %s",
                request.getMethod(), request.getRequestURL().toString()));

        Object token = request.getParameter("token");
        if (null == token) {
            log.error("error: token is empty");
            return fail(401, "error: token is empty");
        }

        return success();
    }

    /**
     * filterOrder() must also be defined for a filter. Filters may have the same  filterOrder if precedence is not
     * important for a filter. filterOrders do not need to be sequential.
     *
     * @return the int order of a filter
     */
    @Override
    public int filterOrder() {
        return 1;
    }
}

~~~



#### 自定义限流过滤器

重写filterOrder，设置order为2

用guava提供的RateLimiter

可以对所有请求限流，也可以通过对每个ip缓存，实现对单个ip的限流

~~~java
package com.imooc.coupon.filter;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.util.concurrent.RateLimiter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

/**
 * 限流过滤器
 */
@Slf4j
@Component
@SuppressWarnings("all")
public class RateLimiterFilter extends AbstractPreZuulFilter {
    // 通过缓存每个IP的限流器，设置超时时间。
    LoadingCache<String, RateLimiter> ipRequestCaches = CacheBuilder.newBuilder()
            .maximumSize(1000)// 设置缓存个数
            .expireAfterWrite(1, TimeUnit.MINUTES)
            .build(new CacheLoader<String, RateLimiter>() {
                @Override
                public RateLimiter load(String s) throws Exception {
                    return RateLimiter.create(1.0);// 新的IP初始化 (限流每秒0.1个令牌响应,即10s一个令牌)
                }
            });

    // 每秒可以获取到两个令牌
    RateLimiter rateLimiter = RateLimiter.create(2.0);

    @Override
    protected Object cRun() {
        // 拿到request
        HttpServletRequest request = context.getRequest();

        //1. 对所有请求限流
        // 尝试获取令牌
//        if (rateLimiter.tryAcquire()) {
//            log.info("get rate token success");
//            return success();
//        } else {
//            log.error("rate limit: {}", request.getRequestURI());
//            return fail(402, "error: rate limit");
//        }
        //2. 对单个ip的请求限流
        try {
            String ip = request.getRemoteAddr();
            RateLimiter rateLimiter = ipRequestCaches.get(ip);
            if (rateLimiter.tryAcquire()){
                log.info("ip:"+ip+" 通过");
                return success();
            }else {
                log.info("ip:"+ip+" 被限流");
                return fail(402,"error: 限流");
            }
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * filterOrder() must also be defined for a filter. Filters may have the same  filterOrder if precedence is not
     * important for a filter. filterOrders do not need to be sequential.
     *
     * @return the int order of a filter
     */
    @Override
    public int filterOrder() {
        return 2;
    }
}

~~~



#### 访问日志过滤器

用pre和post两个过滤器来实现访问日志的过滤。这里简单实现一个，**记录请求开始和结束的耗时**。

将信息存储在context

先创建一个pre，order设置为0，请求进来第一个过滤器就记录时间戳

~~~java
package com.imooc.coupon.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * 在过滤器中存储客户端发起请求的时间戳
 */
@Slf4j
@Component
public class PreRequestFilter extends AbstractPreZuulFilter {

    @Override
    protected Object cRun() {
        // 存储发起请求的时间戳
        context.set("startTime", System.currentTimeMillis());

        return success();
    }

    /**
     * filterOrder() must also be defined for a filter. Filters may have the same  filterOrder if precedence is not
     * important for a filter. filterOrders do not need to be sequential.
     *
     * @return the int order of a filter
     */
    @Override
    public int filterOrder() {
        return 0;
    }
}

~~~

创建post过滤器，设置order为最后一个

~~~java
package com.imooc.coupon.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;

/**
 * Created by Qinyi.
 */
@Slf4j
@Component
public class AccessLogFilter extends AbstractPostZuulFilter {

    @Override
    protected Object cRun() {

        HttpServletRequest request = context.getRequest();

        // 从 PreRequestFilter 中获取设置的请求时间戳
        Long startTime = (Long) context.get("startTime");
        String uri = request.getRequestURI();
        long duration = System.currentTimeMillis() - startTime;

        // 从网关通过的请求打印延时时间: uri + duration
        log.info("uri: {}, duration: {}", uri, duration);

        return success();
    }

    /**
     * filterOrder() must also be defined for a filter. Filters may have the same  filterOrder if precedence is not
     * important for a filter. filterOrders do not need to be sequential.
     *
     * @return the int order of a filter
     */
    @Override
    public int filterOrder() {
        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;
    }
}

~~~



## common模块

### 作用

- 通用代码定义
- 通用配置定义
- 统一的异常处理
- 统一的响应处理

common模块不需要独立运行，只是作为其他微服务依赖的jar包

### 依赖

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>imooc-coupon-service</artifactId>
        <groupId>com.imooc.coupon</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>

    <artifactId>coupon-common</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <dependencies>
        <!-- 引入 Web 功能 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- JSON 处理工具 -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.31</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.0</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-collections4</artifactId>
            <version>4.0</version>
        </dependency>
    </dependencies>

</project>
~~~

### 定义通用配置

#### 自定义消息转换器

转换器的作用是将HTTP数据转换为Java对象，将Java对象转换为HTTP数据。

默认是根据不同的类型选择默认提供的很多种转换器。这里我们**只指定用JSON的形式转换**。

配置类加上@Configuration，实现WebMvcConfigurer重写configureMessageConverters方法，修改转换器list中的转换器。

~~~java
package com.imooc.coupon.conf;

import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.List;

/**
 * 定制 HTTP 消息转换器
 */
@Configuration
public class WebConfiguration implements WebMvcConfigurer {

    @Override
    public void configureMessageConverters(
            List<HttpMessageConverter<?>> converters) {
        //  清除默认的所有转换器
        converters.clear();
        // 只放入一个指定的转换器
        converters.add(new MappingJackson2HttpMessageConverter());
    }
}

~~~



#### 自定义jackson

~~~java
package com.imooc.coupon.conf;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.text.SimpleDateFormat;

/**
 * Jackson 的自定义配置
 */
@Configuration
public class JacksonConfig {

    // 注入到容器
    @Bean
    public ObjectMapper getObjectMapper() {

        ObjectMapper mapper = new ObjectMapper();
        mapper.setDateFormat(new SimpleDateFormat(
                "yyyy-MM-dd HH:mm:ss"
        ));
        return mapper;
    }
}

~~~

### 统一响应

![image-20201009203544308](优惠券项目.assets/image-20201009203544308.png)

编写一个统一响应类

#### 自定义注解

编写一个注解，来忽略统一响应，表示标记的类或者方法返回的类型不要去处理。在对ResponseBody进行后处理时，会判断是否有这个注解来进行忽略。

~~~java
package com.imooc.coupon.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 忽略统一响应注解定义
 */
// Target表示注解可以标注在什么类型上面，可以标注在类或者方法上面
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface IgnoreResponseAdvice {
}

~~~

#### 定义统一返回类型

~~~java
package com.imooc.coupon.vo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 通用响应对象定义
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CommonResponse<T> implements Serializable {

    private Integer code;
    private String message;
    private T data;

    public CommonResponse(Integer code, String message) {

        this.code = code;
        this.message = message;
    }
}

~~~



#### RestControllerAdvice

定义ResponseBody处理的代码

通过这个组件对所有controller返回的ResponseBody进行拦截后处理。去**实现ResponseBodyAdvice接口，表示@RestControllerAdvice注解**

实现两个方法：

- supports：判断是否需要进行后处理。这里去判断是否有上面定义的注解，来忽略后处理。
- beforeBodyWrite：做后处理的逻辑。在这里去写包装body的代码
  - 在这里需要有个逻辑，去判断返回的对象类型是不是CommonResponse，如果是就直接返回这个构件好的CommonResponse。这种情况是为了：比如想返回code和message不是上面默认的，就自己在创建CommonResponse，这里就不帮忙了。其实也可以通过注解忽略。

~~~java
package com.imooc.coupon.advice;

import com.imooc.coupon.annotation.IgnoreResponseAdvice;
import com.imooc.coupon.vo.CommonResponse;
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

/**
 * 统一响应
 * 对ResponseBody进行增强
 */
@RestControllerAdvice
public class CommonResponseDataAdvice implements ResponseBodyAdvice<Object> {

    /**
     * <h2>判断是否需要对响应进行处理</h2>
     * */
    @Override
    @SuppressWarnings("all")
    public boolean supports(MethodParameter methodParameter,
                            Class<? extends HttpMessageConverter<?>> aClass) {

        // 如果当前方法所在的类标识了 @IgnoreResponseAdvice 注解, 不需要处理
        if (methodParameter.getDeclaringClass().isAnnotationPresent(
                IgnoreResponseAdvice.class
        )) {
            return false;
        }

        // 如果当前方法标识了 @IgnoreResponseAdvice 注解, 不需要处理
        if (methodParameter.getMethod().isAnnotationPresent(
                IgnoreResponseAdvice.class
        )) {
            return false;
        }

        // 对响应进行处理, 执行 beforeBodyWrite 方法
        return true;
    }

    /**
     * <h2>响应返回之前的处理</h2>
     * */
    @Override
    @SuppressWarnings("all")
    public Object beforeBodyWrite(Object o,
                                  MethodParameter methodParameter,
                                  MediaType mediaType,
                                  Class<? extends HttpMessageConverter<?>> aClass,
                                  ServerHttpRequest serverHttpRequest,
                                  ServerHttpResponse serverHttpResponse) {

        // 定义最终的返回对象
        CommonResponse<Object> response = new CommonResponse<>(
                0, ""
        );

        // 如果 o 是 null, response 不需要设置 data，直接返回对象
        if (null == o) {
            return response;
            // 在controller中可以去自行返回CommonResponse对象，如果是这种情况就这里就不再封装
        } else if (o instanceof CommonResponse) {
            response = (CommonResponse<Object>) o;
        } else {// 否则, 把响应对象作为 CommonResponse 的 data 部分
            response.setData(o);
        }

        return response;
    }
}

~~~









### 统一异常处理

![image-20201010090406473](优惠券项目.assets/image-20201010090406473.png)

统一异常处理的好处：

- 不直接显示错误，对用户友好
- 异常分类，便于排查问题
- 降低业务代码中对异常处理的耦合

也是通过对controller增强后处理的形式，去处理抛出的异常。

#### 定义异常

继承Exception

~~~java
package com.imooc.coupon.exception;

/**
 * <h1>优惠券项目通用异常定义</h1>
 */
public class CouponException extends Exception {

    public CouponException(String message) {
        super(message);
    }
}

~~~

#### RestControllerAdvice

也是用RestControllerAdvice对controller增强

用@ExceptionHandler去处理异常



## 功能微服务

### 业务思想

#### 优惠券模板模块

包含有三个功能点

>  根据运营人员设定条件构造优惠券模板。
>
> 作用：方便优惠券生成，只要创建好模板后，输入数量就能直接生成优惠券。

一个优惠券包括的信息可以有：名称、logo、分类、产品线、数量、规则等。一个优惠券必须有**优惠券码**。生成优惠券必须有数量限制。

核心：

- 异步：生成优惠券的过程的异步的，可以在之后查看生成的优惠券
- 优惠券码：
  - 设计为：18位，不可重复，有一定识别性
    - 产品线+类型（4位）  日期（6位）  0-9随机数（8位）



> 根据模板生成优惠券，并保存到Redis中

核心：

- 通过静态的方式去生成优惠券：给定数量直接全部生成，而不是用户请求再生成。
- 用单实例去生成：

为什么？

解决一致性问题，通过放在Set保证不重复。放在单实例中静态生成就不用考虑超发和配额问题。如果多个实例根据用户请求动态生成优惠券，这样为了保证多个实例不超发，要给每个实例设置配额，并且还要保证负载均衡的效果。



> 清理过期优惠券模板

参考Redis的过期策略

方法：

- 定时：通过定时任务定期检查，清除过期模板。
- 惰性：在使用模板时再去检查是否过期。



#### 优惠券分发模块



> 根据用户id和优惠券状态查找用户优惠券记录

关键：

- 因为不涉及用户系统，用户id不需要做校验，用mock数据
- 优惠券状态有三类：可用的、已使用的、过期的（未被使用）
- 用户数据存储在Redis中
- 获取用户优惠券，延时处理过期

![image-20201010095659816](优惠券项目.assets/image-20201010095659816.png)

核心流程：

- 用户根据状态查询自己的优惠券
- 分发模块会从Redis中查询优惠券
- 检查，如果存在过期优惠券，就通过Kafka，异步会写MySQL



> 根据用户id，查找可以领取的优惠券模板

- 分发模块从模板模块获取模板（熔断兜底）。访问任何微服务模块都会有不确定性。
- 根据优惠券领取限制，对比用户拥有的优惠券，做出判断

![image-20201010100205132](优惠券项目.assets/image-20201010100205132.png)



> 用户领取优惠券

- 先查找可用模板，上一条
- 从Redis中获取优惠券码
- 优惠券写入MySQL和Redis中

![image-20201010100517841](优惠券项目.assets/image-20201010100517841.png)



> 结算（核销）优惠券
>
> 结算：计算优惠券可以减免的金额。相当于只查看数据库
>
> 核销：使用优惠券。对数据库数据进行修改

- 校验需要结算的优惠券是否合法（属于用户并且可用）
- 利用结算模块计算结算数据
- 如果需要核销，需要用Kafka异步回写数据库



#### 优惠券结算模块

