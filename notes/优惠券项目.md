

# 准备

## Redis





## MySQL

用8，设置mysql的默认时区

![image-20200823003520638](优惠券项目.assets/image-20200823003520638.png)

## Kafka

### 消息系统

- 点对点消息系统
- 发布订阅消息系统

![image-20200823225848666](优惠券项目.assets/image-20200823225848666.png)

Kafka是一个分布式的发布订阅消息系统

![image-20200823231037874](优惠券项目.assets/image-20200823231037874.png)

- Topic：划分数据的类
- partition：每个Topic至少有一个partition。同一个partition里的数据是有序的，不同partition的数据可能是无序的，发送的消息可能进入p1或者p2
- Brokers：一个集群有多台服务器，一个服务器有一个Brokers，存储Topic中的数据，来维护负载均衡。
- producer：数据发布者，将消息发送到Topic，Brokers接收到消息后，把消息追加到partition中
- consumer：消费者，可以消费多个Topic中的数据。多个消费者可以组成消费者组。



### 安装

下载压缩包

打开config文件夹中server.properties

- broker.id：集群中唯一标识，这里默认就好
  - ![image-20200830002705532](优惠券项目.assets/image-20200830002705532.png)
- log.dirs：日志地址，根据需求自己修改
  - ![image-20200830002645796](优惠券项目.assets/image-20200830002645796.png)



![image-20200830002729653](优惠券项目.assets/image-20200830002729653.png)

- 先启动zk
- 启动kafka-server
- 创建topic
  - bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic first-kafka-topic
  - ![image-20200830003408049](优惠券项目.assets/image-20200830003408049.png)
- 查看topic
  - bin/kafka-topics.sh --list --zookeeper localhost:2181
- 启动消费者
  - bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first-kafka-topic --from-beginning
- 启动生产者
  - bin/kafka-console-producer.sh --broker-list localhost:9092 --topic first-kafka-topic
  - ![image-20200830003918464](优惠券项目.assets/image-20200830003918464.png)



### 生产者消费者

![image-20200830004055871](优惠券项目.assets/image-20200830004055871.png)

消息中key的作用

- 提供描述消息的额外信息
- 决定消息写入哪个分区，相同key的消息肯定会分配到同一个分区



![image-20200830004400321](优惠券项目.assets/image-20200830004400321.png)

一个topic中的分区只会消费一次，不管消费者组中有多少个消费者

![image-20200830004643083](优惠券项目.assets/image-20200830004643083.png)

消费者组中消费者数量应该小于一个topic中分区的数量

![image-20200830004725152](优惠券项目.assets/image-20200830004725152.png)



### docker中安装



# Springboot相关



# SpringCloud

## Eureka

注册中心

包含两个组件

- Eureka Server
- Eureka Client
  - Service Provider：服务注册、心跳续约（告诉Server自己还活着）、下线（自己要下线，让Server删除自己的原信息）
  - Service Consumer：获取服务注册信息

Eureka用一个map管理原信息

~~~java
// 第一个key存储服务名称，第二个key存储实例名称，value表示实例的信息
ConcurrentHashMap<String,Map<String,Lease<InstanceInfo>>>
~~~



### 创建一个Eureka应用

引入依赖

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>imooc-coupon</artifactId>
        <groupId>com.imooc.coupon</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>

    <artifactId>coupon-eureka</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <!-- 模块名及描述信息 -->
    <name>coupon-eureka</name>
    <description>Spring Cloud Eureka For Coupon</description>

    <!-- eureka server: 提供服务发现与服务注册 -->
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
    </dependencies>

    <!--
        SpringBoot的Maven插件, 能够以Maven的方式为应用提供SpringBoot的支持，可以将
        SpringBoot应用打包为可执行的jar或war文件, 然后以通常的方式运行SpringBoot应用
     -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>


</project>
~~~



启动类，注意多了个Eureka的注解

~~~java
@EnableEurekaServer
@SpringBootApplication
public class EurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
~~~

配置application.yml

~~~yml
spring:
  application:
    name: coupon-eureka

server:
  port: 8000

eureka:
  instance:
    hostname: localhost
  client:
    # 标识是否从 Eureka Server 获取注册信息, 默认是 true. 如果这是一个单节点的 Eureka Server
    # 不需要同步其他节点的数据, 设置为 false
    fetch-registry: false
    # 是否将自己注册到 Eureka Server, 默认是 true. 由于当前应用是单节点的 Eureka Server
    # 需要设置为 false
    register-with-eureka: false
    # 设置 Eureka Server 所在的地址, 查询服务和注册服务都需要依赖这个地址
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
  server:
    enable-self-preservation: false
#    renewal-percent-threshold: 0.45
~~~



本地模拟多实例集群

配置文件

~~~yml
spring:
  application:
    name: coupon-eureka
  profiles: server1
server:
  port: 8000
eureka:
  instance:
  # eureka不允许单机多实例，同一个ip不通过，这里用用host
    hostname: server1
    prefer-ip-address: false
  client:
    service-url:
      defaultZone: http://server2:8001/eureka/,http://server3:8002/eureka/

---
spring:
  application:
    name: coupon-eureka
  profiles: server2
server:
  port: 8001
eureka:
  instance:
    hostname: server2
    prefer-ip-address: false
  client:
    service-url:
      defaultZone: http://server1:8000/eureka/,http://server3:8002/eureka/

---
spring:
  application:
    name: coupon-eureka
  profiles: server3
server:
  port: 8002
eureka:
  instance:
    hostname: server3
    prefer-ip-address: false
  client:
    service-url:
      defaultZone: http://server1:8000/eureka/,http://server2:8001/eureka/

~~~

maven打包

~~~bash
mvn clean package -Dmaven.test.skip=true -U
~~~

进入项目target，找到eureka的jar包，根据不同配置启动三个eureka

~~~bash
java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active=server1
java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active=server2
java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active=server3

~~~



## Zuul

是一个API 网关服务器，本质上就是一个Web Servlet应用

提供了动态路由、监控等服务。（实现的核心就是过滤器）

![image-20200907204400273](优惠券项目.assets/image-20200907204400273.png)

### 过滤器类型

- pre filters
- routing filters
- post filters
- error filters



自定义Zuul过滤器

需要继承ZuulFilter，并实现四个抽象方法

- filterType：对应Zuul生命周期的四个阶段
- filterOrder：过滤器的优先级，数字越小优先级越高
- shouldFilter：返回true就执行run方法
- run：过滤逻辑



### 搭建网关服务

依赖

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>imooc-coupon</artifactId>
        <groupId>com.imooc.coupon</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>

    <artifactId>coupon-gateway</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <!-- 模块名及描述信息 -->
    <name>coupon-gateway</name>
    <description>Spring Cloud Gateway For Coupon</description>

    <dependencies>
        <!--
            Eureka 客户端, 客户端向 Eureka Server 注册的时候会提供一系列的元数据信息, 例如: 主机, 端口, 健康检查url等
            Eureka Server 接受每个客户端发送的心跳信息, 如果在某个配置的超时时间内未接收到心跳信息, 实例会被从注册列表中移除
        -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!-- 服务网关 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
        </dependency>
        <!-- apache 工具类 -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>1.3.2</version>
        </dependency>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>16.0</version>
        </dependency>
    </dependencies>

    <!--
        SpringBoot的Maven插件, 能够以Maven的方式为应用提供SpringBoot的支持，可以将
        SpringBoot应用打包为可执行的jar或war文件, 然后以通常的方式运行SpringBoot应用
     -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
~~~



启动类

两个新注解

~~~java
/**
 * <h1>网关应用启动入口</h1>
 * 1. @EnableZuulProxy 标识当前的应用是 Zuul Server
 * 2. @SpringCloudApplication 组合了 SpringBoot 应用 + 服务发现 + 熔断
 */
@EnableZuulProxy
@SpringCloudApplication
public class ZuulGatewayApplication {

    public static void main(String[] args) {

        SpringApplication.run(ZuulGatewayApplication.class, args);
    }
}

~~~

配置

~~~yml
server:
  port: 9000

spring:
  application:
    name: coupon-gateway

eureka:
  client:
    service-url:
      defaultZone: http://server1:8000/eureka/

zuul:
  prefix: /imooc
  routes:
    # 优惠券模板微服务路由配置定义
    template:
      path: /coupon-template/**
      serviceId: eureka-client-coupon-template
      strip-prefix: false
    # 优惠券分发微服务路由配置定义
    distribution:
      path: /coupon-distribution/**
      serviceId: eureka-client-coupon-distribution
      strip-prefix: false
    # 优惠券结算微服务路由配置定义
    settlement:
      path: /coupon-settlement/**
      serviceId: eureka-client-coupon-settlement
      strip-prefix: false
  host:
    connect-timeout-millis: 15000
    socket-timeout-millis: 60000

ribbon:
  ConnectTimeout: 15000
  ReadTimeout: 15000

~~~

#### 编写抽象过滤器

要继承ZuulFilter

ZuulFilter中主要四个需要实现的方法

- public abstract String filterType();确定过滤器的类型，不同类型的过滤器执行点不同
- public abstract int filterOrder();确定同类型过滤器的执行顺序
- boolean shouldFilter();返回true就执行run方法。
- Object run() throws ZuulException;run为过滤器主要逻辑

在这个继承ZuulFilter的抽血过滤器中，先只实现shouldFilter和run。对于针对具体类型的过滤器，再通过继承去实现。

~~~java
package com.imooc.coupon.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;

/**
 * <h1>通用的抽象过滤器类</h1>
 * Created by Qinyi.
 */
public abstract class AbstractZuulFilter extends ZuulFilter {

    // 用于在过滤器之间传递消息, 数据保存在每个请求的 ThreadLocal 中
    // 扩展了 Map
    RequestContext context;

    private final static String NEXT = "next";

    /**
     * a "true" return from this method means that the run() method should be invoked
     *
     * @return true if the run() method should be invoked. false will not invoke the run() method
     */
    @Override
    public boolean shouldFilter() {

        RequestContext ctx = RequestContext.getCurrentContext();
        return (boolean) ctx.getOrDefault(NEXT, true);
    }

    /**
     * if shouldFilter() is true, this method will be invoked. this method is the core method of a ZuulFilter
     *
     * @return Some arbitrary artifact may be returned. Current implementation ignores it.
     * @throws ZuulException if an error occurs during execution.
     */
    @Override
    public Object run() throws ZuulException {

        context = RequestContext.getCurrentContext();
        return cRun();
    }

    protected abstract Object cRun();

    Object fail(int code, String msg) {

        context.set(NEXT, false);
        context.setSendZuulResponse(false);
        context.getResponse().setContentType("text/html;charset=UTF-8");
        context.setResponseStatusCode(code);
        context.setResponseBody(String.format("{\"result\": \"%s!\"}", msg));

        return null;
    }

    Object success() {

        context.set(NEXT, true);

        return null;
    }
}

~~~

创建对应类型的抽象过滤器类，这样可以把一些通用的部分复用。

~~~java
package com.imooc.coupon.filter;

import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;

/**
 * Created by Qinyi.
 */
public abstract class AbstractPostZuulFilter extends AbstractZuulFilter {

    /**
     * to classify a filter by type. Standard types in Zuul are "pre" for pre-routing filtering,
     * "route" for routing to an origin, "post" for post-routing filters, "error" for error handling.
     * We also support a "static" type for static responses see  StaticResponseFilter.
     * Any filterType made be created or added and run by calling FilterProcessor.runFilters(type)
     *
     * @return A String representing that type
     */
    @Override
    public String filterType() {
        return FilterConstants.POST_TYPE;
    }
}

~~~

#### 自定义Token过滤器

他是在过滤器的最前面，所以是pre类型

继承pre抽象类，去重写实现run和filterOrder

这里具体的验证逻辑就不写了，大概流程是这样的

~~~java
package com.imooc.coupon.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;

/**
 * <h1>校验请求中传递的 Token</h1>
 * Created by Qinyi.
 */
@Slf4j
//@Component
public class TokenFilter extends AbstractPreZuulFilter {

    @Override
    protected Object cRun() {

        HttpServletRequest request = context.getRequest();
        log.info(String.format("%s request to %s",
                request.getMethod(), request.getRequestURL().toString()));

        Object token = request.getParameter("token");
        if (null == token) {
            log.error("error: token is empty");
            return fail(401, "error: token is empty");
        }

        return success();
    }

    /**
     * filterOrder() must also be defined for a filter. Filters may have the same  filterOrder if precedence is not
     * important for a filter. filterOrders do not need to be sequential.
     *
     * @return the int order of a filter
     */
    @Override
    public int filterOrder() {
        return 1;
    }
}

~~~



xian