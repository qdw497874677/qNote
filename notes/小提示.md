### 类加载过程

- 加载：根据类全限定名加载字节码，解析出数据结构放到方法区，在堆中创建能访问方法区信息的Class实例。
- 连接：验证：确保字节码符合虚拟机-准备：在方法区给类变量分配内存赋值-解析：将类的符号引用替换为直接引用。
- 初始化：执行类构造器：其中包括对static变量的复制和static代码块的语句。优先初始化父类

### 双亲委派

类加载器优先尝试让父类加载器加载，不行再自己加载，这样尽量保证核心类优先加载，而不被替代。

启动类加载器：C++编写，是JVM的一部分。拓展类加载器：Java编写。系统类加载器：Java编写。用户自定义加载器：继承系统类加载器

### 数据库三大范式

1. 要求数据库的每一个字段都是不可分割的
2. 在1的基础上，确保每一个字段都和主键相关，而不是和主键的某一部分相关
3. 在2的基础上，确保每一个字段都是和主键直接相关，而不是间接相关。
   1. 假如某个字段依赖于另一个字段，应该拆成另一个表

### ACID

A：原子性 C：一致性 I：隔离性 D：持久性

### MySQL架构

- Server层：连接器、分析器、优化器、执行器
- 存储引擎层：MyISAM、InnoDB
  - InnoDB支持事务，有索引，支持表、行锁。MyISAM允许没有索引和主键的表存在，只能用表锁。

### Volatile

保证可见性，禁止指令重排。volatile修饰的变量的写操作在汇编代码中，会有一个lock前缀，保证会立刻把值写回到主存中，同时其他CPU缓存中的这个变量会被置为无效，在使用时需要重新从主存拿。

### Syschronized

java关键字，可以修饰方法和代码块。方法：标记这个方法为同步方法，之前前需要先获得对象的监视器。代码块：字节码在前后使用monitorenter和monitorexit标记，也是需要获取对象监视器才能执行。

### ThreadLocal

每个线程中都有两个个ThreadLocalMap类型的变量，一个存储本线程的值，一个存储父线程的值。他们可以通过ThreadLocal的get和set去操作，ThreadLocal就是通过Thread间接地操作这些值。ThreadLocalMap是Map，线程作为key

### 死锁

条件：互斥、不剥夺、请求和保持、循环等待。通过jps -l定位java出问题的进程，通过jstack 进程id显示详情

避免：1.按指定顺序加锁2.给获取锁加个超时时间3.通过在数据结构中构建依赖锁的链表，如果有环说明有死锁，可以选择自己释放所有锁，或者根据随机优先级让其他线程释放锁

### Redis

处理过期数据：定期随机检查、惰性删除

内存淘汰：内存占用过大时删除数据：1.写时报错 2.LRU 3.随机删一个 4.有设置过期的LRU 5.随机删一个设置过期的 6.删除最快要过期的

跳跃表：支持随机插入和删除，查找效率高，有序。结构简单，相对平衡树不需要做过多平衡的动作。原理：链表中没次插入节点，随机分配层数，层数越高包含的节点越少，所在层中相邻节点跳过的低层的节点数就越多，通过高层链表的遍历可以加快整个完整链表的遍历速度。同时插入和删除影响很小。

### 布隆过滤器



### 基础

线程通信：文件、signal（除了特殊信号，一般可忽略捕获默认动作，一般默认动作是退出）、管道（ps -ef|grep）、socket

### 异常

- Throwable
  - Error：错误。无法被程序处理，OOM、ThreadDeath
  - Exception：异常。能被操作，比如抛出和catch。
    - 非运行时：不处理编译不能通过。IOException，ClassNotFoundException。
    - RuntimeException：编译器不会检查。NullPointerException、ArrayIndexOutOfBoundsException

### Socket

用来抽象进程之间的通信。客户端创建Socket实例，分配端口号，保定远程地址和端口号，三次握手之后，返回Socket实例。服务端创建ServerSocket实例，执行端口号。调用accept()开始监听进入阻塞，连接到来创建套接字，来和客户端交互。

### 数据结构

HashMap

Cur

ThreadLocal

### 排序

稳定：冒泡n2、插入n2、归并nlogn

不稳定：选择n2、快速nlogn、堆nlogn（建堆n，维护堆logn）