### 类加载过程

- 加载：根据类全限定名加载字节码，解析出数据结构放到方法区，在堆中创建能访问方法区信息的Class实例。
- 连接：验证：确保字节码符合虚拟机-准备：在方法区给类变量分配内存赋值-解析：将类的符号引用替换为直接引用。
- 初始化：执行类构造器：其中包括对static变量的复制和static代码块的语句。优先初始化父类

### 双亲委派

类加载器优先尝试让父类加载器加载，不行再自己加载，这样尽量保证核心类优先加载，而不被替代。

启动类加载器：C++编写，是JVM的一部分。拓展类加载器：Java编写。系统类加载器：Java编写。用户自定义加载器：继承系统类加载器。（可以通过重写loadClass方法打破双亲委派、加载的类可能被卸载）

### CMS

关注停顿时间，基于标记清除，与应用线程并发，老年代。初始标记（STW）：**标记GCRoots直接**可达的；并发标记：根据对象**递归标记**可达；并发预清除：对变化的**重新标记**；重新标记（STW）：递归标记没有处理过的对象；并发清除。缺点：很吃吞吐量，无法收集浮动垃圾（需要提前进行回收），有内存碎片。

### 数据库三大范式

1. 要求数据库的每一个字段都是不可分割的
2. 在1的基础上，确保每一个字段都和主键相关，而不是和主键的某一部分相关
3. 在2的基础上，确保每一个字段都是和主键直接相关，而不是间接相关。
   1. 假如某个字段依赖于另一个字段，应该拆成另一个表

### ACID

A：原子性 C：一致性 I：隔离性 D：持久性

### MySQL架构

- Server层：连接器、分析器、优化器、执行器
- 存储引擎层：MyISAM、InnoDB
  - InnoDB支持事务，有索引，支持表、行锁。MyISAM允许没有索引和主键的表存在，只能用表锁。

### 优化

索引：最左匹配。联表查，被关联的表对应的字段要有索引。尽量使用覆盖索引来避免回表。

limit优化：把联表查询拆成，主表关联子查询，只对子查询做limit，子查询查出主键id。

### Volatile

保证可见性，禁止指令重排。volatile修饰的变量的写操作在汇编代码中，会有一个lock前缀，保证会立刻把值写回到主存中，同时其他CPU缓存中的这个变量会被置为无效，在使用时需要重新从主存拿。

### Syschronized

java关键字，可以修饰方法和代码块。方法：标记这个方法为同步方法，之前前需要先获得对象的监视器。代码块：字节码在前后使用monitorenter和monitorexit标记，也是需要获取对象监视器才能执行。

### ThreadLocal

每个Thread类对应一个ThreadLocalMap类型的变量，每个ThreadLocalMap（即threadLocals）可以存储多个ThreadLocal实例（都是属于本线程的），存储以ThreadLocal为key的键值对。ThreadLocal实例可以通过获取当前线程获取ThreadLocalMap类型变量，然后根据自身ThreadLocal实例作为key找到对应的值，这个值就是当前线程中这个ThreadLocal实例对应set存储的值。

### 死锁

条件：互斥、不剥夺、请求和保持、循环等待。通过jps -l定位java出问题的进程，通过jstack 进程id显示详情

避免：1.按指定顺序加锁2.给获取锁加个超时时间3.通过在数据结构中构建依赖锁的链表，如果有环说明有死锁，可以选择自己释放所有锁，或者根据随机优先级让其他线程释放锁

### Redis

处理过期数据：定期随机检查、惰性删除

内存淘汰：内存占用过大时删除数据：1.写时报错 2.LRU 3.随机删一个 4.有设置过期的LRU 5.随机删一个设置过期的 6.删除最快要过期的

跳跃表：支持随机插入和删除，查找效率高，有序。结构简单，相对平衡树不需要做过多平衡的动作。原理：链表中没次插入节点，随机分配层数，层数越高包含的节点越少，所在层中相邻节点跳过的低层的节点数就越多，通过高层链表的遍历可以加快整个完整链表的遍历速度。同时插入和删除影响很小。

RDB：指定时间间隔将内存数据快照写入磁盘。fork一个子进程先写入临时文件，写入成功后覆盖到上次持久化好的RDB文件中。写入性能好，恢复速度快，适合灾难恢复。可能会丢失小部分数据

AOF：以日志形式记录写（删）操作，追加文件中，可选同步策略。最大限度避免数据丢失，但是恢复慢，运行效率低。

### 布隆过滤器



### 基础

线程通信：文件、signal（除了特殊信号，一般可忽略捕获默认动作，一般默认动作是退出）、管道（ps -ef|grep）、socket

### 中断

### 异常

- Throwable
  - Error：错误。无法被程序处理，OOM、ThreadDeath
  - Exception：异常。能被操作，比如抛出和catch。
    - 非运行时：不处理编译不能通过。IOException，ClassNotFoundException。
    - RuntimeException：编译器不会检查。NullPointerException、ArrayIndexOutOfBoundsException

### HTTP

- 客户端请求发送可用的加密方式，服务端收到后相应，把自己的证书和公钥发给客户端
- 客户端验证证书，生成一个对称的会话秘钥，用公钥加密后发给服务器
- 服务器收到后，用私钥解密得到密钥，然后和客户端相互检验，就握手完成了简历SSL连接

### Socket

用来抽象进程之间的通信。客户端创建Socket实例，分配端口号，保定远程地址和端口号，三次握手之后，返回Socket实例。服务端创建ServerSocket实例，执行端口号。调用accept()开始监听进入阻塞，连接到来创建套接字，来和客户端交互。

### 数据结构

HashMap

Cur

ThreadLocal

### linux

netstat -ap | grep ssh

top

### 排序

稳定：冒泡n2、插入n2、归并nlogn

不稳定：选择n2、快速nlogn、堆nlogn（建堆n，维护堆logn）

### 项目

数据库主要操作：查博文带分类和标签，怎么映射。查对应博文最多的分类group by

Redis：存博文，存分数为view的博文排行榜。存任务用list，lpush放brpop取。用zset做时延队列，值为任务Json，用score存任务处理的时间，定时任务每1秒从zset中取0到当前时间范围的元素，zrange key 0 -1。用work类表示任务，用不同的hander子类组成责任链来处理work。防缓存穿透，用存null字符串。缓存一致性：博文查Redis没有或者过期了从MySQL中查，在增删改的时候把对应的更新Redis的任务放到队列中取处理。开始就放到Java内存的阻塞队列中。有个启动任务用take去消费。view是更新Redis，定时任务同步到MySQL，