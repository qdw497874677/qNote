## 类加载过程

- 加载：根据类全限定名加载字节码，解析出数据结构放到方法区，在堆中创建能访问方法区信息的Class实例。
- 连接：验证：确保字节码符合虚拟机-准备：在方法区给类变量分配内存赋值-解析：将类的符号引用替换为直接引用。
- 初始化：执行类构造器：其中包括对static变量的复制和static代码块的语句。优先初始化父类

## 双亲委派

类加载器优先尝试让父类加载器加载，不行再自己加载，这样尽量保证核心类优先加载，而不被替代。

启动类加载器：C++编写，是JVM的一部分。拓展类加载器：Java编写。系统类加载器：Java编写。用户自定义加载器：继承系统类加载器

## 数据库三大范式

1. 要求数据库的每一个字段都是不可分割的
2. 在1的基础上，确保每一个字段都和主键相关，而不是和主键的某一部分相关
3. 在2的基础上，确保每一个字段都是和主键直接相关，而不是间接相关。
   1. 假如某个字段依赖于另一个字段，应该拆成另一个表

## ACID

A：原子性 C：一致性 I：隔离性 D：持久性

## MySQL架构

- Server层：连接器、分析器、优化器、执行器
- 存储引擎层：MyISAM、InnoDB
  - InnoDB支持事务，有索引，支持表、行锁。MyISAM允许没有索引和主键的表存在，只能用表锁。

## Volatile

保证可见性，禁止指令重排。volatile修饰的变量的写操作在汇编代码中，会有一个lock前缀，保证会立刻把值写回到主存中，同时其他CPU缓存中的这个变量会被置为无效，在使用时需要重新从主存拿。

## Syschronized

java关键字，可以修饰方法和代码块。方法：标记这个方法为同步方法，之前前需要先获得对象的监视器。代码块：字节码在前后使用monitorenter和monitorexit标记，也是需要获取对象监视器才能执行。

## ThreadLocal

每个线程中都有两个个ThreadLocalMap类型的变量，一个存储本线程的值，一个存储父线程的值。他们可以通过ThreadLocal的get和set去操作，ThreadLocal就是通过Thread间接地操作这些值。ThreadLocalMap是Map，线程作为key

## 死锁

条件：互斥、不剥夺、请求和保持、循环等待。通过jps -l定位java出问题的进程，通过jstack 进程id显示详情

避免：1.按指定顺序加锁2.给获取锁加个超时时间3.通过在数据结构中构建依赖锁的链表，如果有环说明有死锁，可以选择自己释放所有锁，或者根据随机优先级让其他线程释放锁