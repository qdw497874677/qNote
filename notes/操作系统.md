[**首页**](https://github.com/qdw497874677/myNotes/blob/master/首页检索.md)

# 进程与线程

## 进程

- 进程是程序的一次执行过程，是动态的，是系统资源分配的单位。
- 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，创建和销毁进程都是对PCB的操作。
- 一个进程包含多个线程。
- 操作系统分配给每个进程一些内存寻址空间。进程有自己独立的地址空间。



## 线程

- 线程是CPU调度和执行的单位，一个进程可以有多个线程，他们可以共享进程的公共资源
- 虚拟机栈
- 程序计数器，记录当前要执行的指令。指向内存中，也就是进程的内存。
- TLS，线程自己的内存，用来存放变量。

引入线程可以提高并发度。

## 区别

- 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问所属进程的资源。
- 调度：线程是独立调度的基本单位。在同一进程中，线程的切换不会引起进程切换。从一个进程中的线程切换到另一个进程总的线程时，会引起进程调度。
- 系统开销：创建或撤销进程时，系统要为其分配或回收资源，如内存空间、I/O设备等，付出的开销远大于创建或撤销线程。在进行进程切换时，涉及当前执行进程CPU环境的保存以及新调度进程的CPU环境的设置；而线程切换时**只需保存和设置少量寄存器内容**，开销小。
- 通信：线程间通信通过读写同一进程中的数据间接通信；进程通信需要借助IPC。



## 协程

协程比线程更加轻量级，不受操作系统内核管理，是完全由程序控制的（用户态执行）。

特点：

- 执行效率高：切换由程序控制，切换开销小。
- 不需要锁机制：因为在一个线程内执行，所以不会有变量冲突，控制共享资源只需要判断状态就好了，效率高。

# 为什么进程切换的开销比线程切换大

进程需要很多资源如寄存器，内存，文件等。每当进程切换时，必须考虑保存当前进程的状态并切换。进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码要换出去，以便把执行的进程的内容换进来。

- 切换页目录以使用新的地址空间。
- 切换内核栈和硬件上下文。

主要的性能消耗是：

1. 上下文的切换通过操作系统内核来完成。将寄存器中的内容切换出十分消耗性能。
2. 上下文切换回打乱处理器的缓存机制。

进程的内容是线程的超集，上述问题的影响都很小。

# 进程间通信（IPC）

- 文件
- 信号Signal（kill -9   -15）
  - 信号的处理有三种：
    - 1. 忽略该信号，大多数信号都可以这样处理，SIGKILL、SIGSTOP除外
      2. 捕获信号，用户自定义一个信号处理函数，SIGKILL、SIGSTOP不能被捕获
      3. 系统默认动作，大多数信号的默认动作是终止进程
- 消息队列
- 管道/命名管道
  - ps -ef|grep ？
- 共享内存
- 同步机制，如信号量
- Socket（最常用的）



# 硬链接和软连接的区别

- 硬链接：与普通文件没什么不同，inode（可以理解成指针，指向物理硬盘的一个区块）都指向同一个文件在硬盘中的区块。
- 软链接（符号链接）：保存了其代表的文件的绝对路径，是另一种文件，在硬盘中有独立的区块，访问时替换自身的路径。

# 32位和64位操作系统的区别

进程的寻址空间的大小不同



# 进程调度算法

## 批处理系统

- 先来先服务（FCFS）：按照请求的顺序进行调度。
- 短作业优先（SJF）：每一次总是先调度估运行时间最短的作业。
- 最短剩余时间（SRTN）：最短作业优先的抢占式版本。如果新到的任务的估计运行时间比当前剩余时间还要短，就要挂起当前线程，运行新线程。



## 交互式系统

有大量的用户操作，目标是快速响应。

- 时间片轮转
- 优先级调度
- 多级反馈队列

## 实时系统



# 页面置换算法

- 最佳置换算法（OPT）
- 先进先出置换算法（FIFO）
- 最近最久未使用（LRU）
- 时钟置换算法

# 死锁

死锁产生的四个必要条件

- 互斥：进程对资源进行排他控制。
- 请求并保持：进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺：进程获得的资源在未使用之前，不能进行剥夺，只能自己释放。
- 环路等待：必然会有进程——资源的环形链。

预防死锁

- 破坏请求条件：资源一次性分配
- 破坏保持条件：只要有一个资源得不到分配，就不给这个进程分配其他资源。
- 破坏不可剥夺：可剥夺资源
- 破坏环路等待：资源有序分配，给资源赋予编号，每个进程按标号递增的循序请求资源，释放相反。

## 死锁检测

- Jstack命令
- JConsole工具

## 模拟死锁代码

~~~java
public class Test2 {
    public static void main(String[] args) {
        String A = "A";
        String B = "B";
        new Thread(new Demo(A,B),"线程1").start();
        new Thread(new Demo(B,A),"线程2").start();
    }

}
class Demo implements Runnable{
    private String A;
    private String B;
    public Demo(String A,String B){
        this.A = A;
        this.B = B;
    }
    @SneakyThrows
    @Override
    public void run() {
        synchronized (A){
            System.out.println(Thread.currentThread().getName()+"有"+A+" 还需要"+B);
            TimeUnit.SECONDS.sleep(3);
            synchronized (B){
                System.out.println(Thread.currentThread().getName()+"有"+B+" 也有"+A);
            }
        }
    }
}
~~~



