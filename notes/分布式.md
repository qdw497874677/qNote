[**首页**](https://github.com/qdw497874677/myNotes/blob/master/首页检索.md)

## 负载均衡问题

使用n台缓存服务器时，一种常用的负载均衡方式是，对资源o的请求使用hash(o)=a mod n来映射到某一台缓存服务器。当增加或者减少一套服务器时这种方式可能会改变所有资源对应的hash值，那么所有缓存都失效了，导致集群集中地想原始内容服务器更新缓存。需要**一致性哈希算法**来避免这样的问题。

这种方式要求增加一台缓存服务器时，新的服务器尽量分担存储其他服务器的缓存资源。减少一台缓存服务器时，其他所有服务器可以尽量分担存储它的缓存资源。

**一致性哈希算法**主要思想：将每个缓存服务器与一个或多个哈希值域区间关联起来，其中区间边界通过计算缓存服务器对应的哈希值来决定。如果一个缓存服务器被移除，则它所对应的区间会被并入到邻近的区间，其他的缓存服务器不需要任何改变。





## 分布式锁

在集群中，多台主机都有一个共同的资源，如果不加分布式锁，不同的访问后，他们的结果可能不一样。

分布式锁需要具备的条件

- 一个方法同一时间只能被一台机器的一个线程执行。
  - （Redis）setnx。
- 获取锁，释放锁要高可用高性能。
  - （Redis）setnx。
- 具备可重用。
  - （Redis）在获取锁的时候，判断当前线程是否已经拿到锁了。然后将计数器加减，每获取一次锁加一，每解锁一次减一。
- 具备锁失效机制，防止死锁。
  - （Redis）设置过期时间，为了保证业务完成，每过一定时间重新设置超时时间 ，让业务异步的执行。
- 具备非阻塞锁特性，即没有获得锁可以返回获取锁失败。
  - （Redis）让线程阻塞，然后利用发布订阅解决实时性。



## Redis实现的分布式锁

### Redis

- 加锁

setnx key value

在redis中给key设置一个值，为了避免死锁，给定一个过期时间。保证设置值和过期时间在一个原子操作中。

命令在设置成功时返回1，设置失败时返回0。

- 解锁

将客户端自己的锁的key删除。根据值的uuid和线程自己存的uuid，是否相等，相等就说明是自己的锁，才能解锁。

为了保证原子性，用LUA脚本来完成操作。先判断字符串是否相等，相等就删除key。

缺点：锁不是可重入锁。



## Redisson

~~~java
Rlock product = redisson.getLock("priduct");
product.lock();
priduct.unlock();
~~~





## 测试接口的工具

postman、jmeter





## Thrift







