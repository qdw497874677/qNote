## 数据库

### 主从分离

通过主从分离，把读操作流量转移到从库。



写主库后，如果需要异步的对数据进行处理。可能会出现查从库时没有发现新的数据导致流程出问题。

三种策略：

- 数据冗余：异步消息中带数据
- 使用缓存：使用缓存，异步任务去查询缓存
- 读主库



### 分库分表

数据量进一步提升到下面的程度

- 表数据量很大索引信息无法缓存在内存中，导致需要从磁盘上读取索引数据，影响到性能了。
- 数据库在备份和恢复的时间边长
- 不同模块的数据都在一个主库中，一旦故障都受到影响

就需要分库分表解决

#### 垂直拆分

将数据库的表拆分到多个不同的数据库中。将业务耦合度比较高的表放到一个库中。

单个库中的数据可能还是很大，就需要水平拆分了

#### 水平拆分

将一个数据表拆分到多个数据库或者数据表中。

拆分规则：

- 哈希拆分：对某个字段进行哈希，对数据库数量取余得到数据库索引，对表数量取余得到表索引。
- 范围拆分：根据某个字段的范围分表，比如对创建时间，主要要主动去添加对应的新表。



### ID全局一致

分库分表的情况下建议使用发号器来生成全局唯一ID

为什么不能用UUID作为主键？

- 主键无需降低写入性能：主键索引在B+树中是有序的，**如果无序造成多余的移动开销**，造成页利用不满和页分裂
- 无法利用有序的主键：比如评论表可以用id同时做时间排序功能。
- **不具备业务含义**
- 比较耗费空间：UUID由32个16禁止数字组成的字符串

#### 雪花算法

通过雪花算法来弥补UUID的不足。

核心思想是将64bit的二进制数字分成若干部分，每一部分都存储有特定含义的数据，比如说时间戳、机器ID、序列号等，最终生成全局唯一的有序ID

![img](https://static001.geekbang.org/resource/image/2d/8d/2dee7e8e227a339f8f3cb6e7b47c0c8d.jpg)



机器ID可以再划分为机房ID和机器ID



最终的实现方式有两种：

- 嵌入到业务代码里。要保证每台机器ID的唯一性。可以引入zk等分布式一致性组件保证获取唯一的机器ID
- 作为独立的服务。



### 数据库和NoSQL互补





## 场景

### 计数



### 未读数



